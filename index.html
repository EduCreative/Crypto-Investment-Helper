<!DOCTYPE html>
<html lang="en">
  <head>
    <script>
      // Polyfill for process.env to work in a browser environment
      window.process = window.process || { env: {} };
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Crypto Investment Helper</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script>
      tailwind.config = {
        darkMode: 'class', // Enable dark mode based on class
        theme: {
          extend: {
            colors: {
              'gray-900': '#121212',
              'gray-800': '#1e1e1e',
              'gray-700': '#2a2a2a',
              'gray-600': '#3a3a3a',
              'primary': '#3b82f6',
              'secondary': '#8b5cf6',
              'success': '#22c55e',
              'danger': '#ef4444',
            },
          },
        },
      }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://s3.tradingview.com/tv.js"></script>
    <style>
      @keyframes page-fade-in {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .animate-page-fade-in {
        animation: page-fade-in 0.5s ease-out forwards;
      }
      
      @keyframes favorite-pop {
        0% { transform: scale(1); }
        50% { transform: scale(1.5) rotate(15deg); color: #facc15; } /* Tailwind yellow-400 */
        100% { transform: scale(1) rotate(0deg); }
      }
      .animate-favorite-pop {
        animation: favorite-pop 0.4s ease-in-out;
      }
    </style>
    <!-- Dependencies for the app -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/date-fns@3.6.0/umd/index.js"></script>
    <!-- Add Babel Standalone for in-browser transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script type="importmap">
{
  "imports": {
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.19.0",
    "react": "https://aistudiocdn.com/react@^19.1.1",
    "chart.js/": "https://aistudiocdn.com/chart.js@^4.5.0/",
    "chartjs-adapter-date-fns": "https://aistudiocdn.com/chartjs-adapter-date-fns@^3.0.0",
    "date-fns": "https://aistudiocdn.com/date-fns@^4.1.0",
    "date-fns/": "https://aistudiocdn.com/date-fns@^4.1.0/"
  }
}
</script>
</head>
  <body class="bg-white dark:bg-gray-900 text-gray-800 dark:text-gray-200">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
//========= MODULE IMPORTS =========//
import { GoogleGenAI, Type } from "@google/genai";

//========= APPLICATION CODE =========//
// All application files have been consolidated here to ensure Babel transpiles everything.

//========= From types.ts =========//
type Page = 'Dashboard' | 'Portfolio' | 'Recommendations' | 'Learning Center' | 'Coin Research' | 'Compare' | 'Alerts';

//========= From services/coingeckoApi.ts =========//
const COINGECKO_API_URL = 'https://cors.eu.org/https://api.coingecko.com/api/v3';
const coingeckoCache = new Map();
const COINGECKO_CACHE_TTL = 5 * 60 * 1000;
const TRADING_FEE_RATE = 0.001; // 0.1%

async function fetchWithCache(key, fetcher, cache, ttl) {
  const now = Date.now();
  const cachedItem = cache.get(key);
  if (cachedItem && now < cachedItem.expiry) {
    return Promise.resolve(cachedItem.data);
  }
  try {
    const data = await fetcher();
    cache.set(key, { data, expiry: now + ttl });
    return data;
  } catch (error) {
    if (cachedItem) {
      console.warn(`Returning stale data for key "${key}" due to fetch error.`, error);
      return Promise.resolve(cachedItem.data);
    }
    throw error;
  }
}

const createCoinGeckoApiError = async (response) => {
    let errorMessage = `API request failed with status ${response.status} (${response.statusText}).`;
    if (response.status === 429) {
        errorMessage = "CoinGecko API request failed: 429 Too Many Requests. Please wait a moment before trying again.";
    }
    return new Error(errorMessage);
};

const getTopCoins = async (count = 10) => {
  const cacheKey = `top-coins-${count}`;
  return fetchWithCache(cacheKey, async () => {
    const response = await fetch(`${COINGECKO_API_URL}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=${count}&page=1&sparkline=false`);
    if (!response.ok) throw await createCoinGeckoApiError(response);
    return response.json();
  }, coingeckoCache, COINGECKO_CACHE_TTL);
};

const getCoinsByIds = async (ids) => {
  if (ids.length === 0) return [];
  const cacheKey = `coins-by-ids-${ids.sort().join(',')}`;
  return fetchWithCache(cacheKey, async () => {
    const response = await fetch(`${COINGECKO_API_URL}/coins/markets?vs_currency=usd&ids=${ids.join(',')}&order=market_cap_desc&sparkline=false`);
    if (!response.ok) throw await createCoinGeckoApiError(response);
    return response.json();
  }, coingeckoCache, COINGECKO_CACHE_TTL);
};

const getCoinMarketChart = async (coinId, days = 90) => {
  const cacheKey = `market-chart-${coinId}-${days}`;
  return fetchWithCache(cacheKey, async () => {
    const response = await fetch(`${COINGECKO_API_URL}/coins/${coinId}/market_chart?vs_currency=usd&days=${days}&interval=daily`);
    if (!response.ok) throw await createCoinGeckoApiError(response);
    const data = await response.json();
    return { prices: data.prices, total_volumes: data.total_volumes };
  }, coingeckoCache, COINGECKO_CACHE_TTL);
};

const getCoinDetails = async (coinId) => {
  const cacheKey = `coin-details-${coinId}`;
  return fetchWithCache(cacheKey, async () => {
      const response = await fetch(`${COINGECKO_API_URL}/coins/${coinId}?localization=false&tickers=false&market_data=false&sparkline=false`);
      if (!response.ok) {
        if (response.status === 404) return null;
        throw await createCoinGeckoApiError(response);
      }
      const data = await response.json();
      return {
        description: data.description?.en || "No description available.",
        links: {
          homepage: data.links?.homepage?.[0] || undefined,
          explorer: data.links?.blockchain_site?.[0] || undefined,
          twitter: data.links?.twitter_screen_name ? `https://twitter.com/${data.links.twitter_screen_name}` : undefined,
          reddit: data.links?.subreddit_url || undefined,
          github: data.links?.repos_url?.github?.[0] || undefined,
        },
        devStats: {
          forks: data.developer_data?.forks || 0,
          stars: data.developer_data?.stars || 0,
          subscribers: data.developer_data?.subscribers || 0,
          commits4w: data.developer_data?.commit_count_4_weeks || 0,
        },
        communityStats: {
          twitterFollowers: data.community_data?.twitter_followers || 0,
          redditSubscribers: data.community_data?.reddit_subscribers || 0,
        }
      };
  }, coingeckoCache, COINGECKO_CACHE_TTL);
};

//========= From services/externalApis.ts =========//
const FEAR_AND_GREED_API_URL = 'https://cors.eu.org/https://api.alternative.me/fng/?limit=1';
const externalApiCache = new Map();
const EXTERNAL_API_CACHE_TTL = 5 * 60 * 1000;

const getFearAndGreedIndex = async () => {
    const cacheKey = 'fear-and-greed-index';
    return fetchWithCache(cacheKey, async () => {
        const response = await fetch(FEAR_AND_GREED_API_URL);
        if (!response.ok) throw new Error(`Alternative.me API request failed with status ${response.status}`);
        const apiResponse = await response.json();
        if (apiResponse.metadata.error) throw new Error(`Fear & Greed API error: ${apiResponse.metadata.error}`);
        if (apiResponse?.data?.length > 0) {
            const rawData = apiResponse.data[0];
            return {
                value: parseInt(rawData.value, 10),
                value_classification: rawData.value_classification,
            };
        }
        throw new Error('Invalid data format from Fear & Greed API');
    }, externalApiCache, EXTERNAL_API_CACHE_TTL);
}

//========= From services/geminiService.ts =========//
const GEMINI_API_KEY = process.env.API_KEY;
if (!GEMINI_API_KEY) {
  console.warn("Gemini API key not found. AI features will be disabled.");
}
const ai = GEMINI_API_KEY ? new GoogleGenAI({ apiKey: GEMINI_API_KEY }) : null;

const getDailySummary = async () => {
    if (!ai) return "AI analysis is currently unavailable. Please configure your API key.";
    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: 'Provide a brief, one-sentence summary of the current cryptocurrency market sentiment for a beginner investor. Example: "The market is currently neutral, with strong interest in Bitcoin following recent news."'
        });
        return response.text;
    } catch (error) {
        console.error("Error fetching daily summary:", error);
        return "Could not generate AI summary at this time.";
    }
};

const getPortfolioAnalysis = async (portfolio) => {
    if (!ai) return { overallAssessment: "AI analysis is currently unavailable." };
    const holdingsArray = Object.values(portfolio.holdings);
    if (holdingsArray.length === 0) return {
        overallAssessment: "Your portfolio is empty. Buy some crypto to get AI insights!",
        riskScore: 0, riskAnalysis: "N/A", diversification: "N/A",
        rebalancingOpportunities: "N/A", positiveNote: "Add your first asset to begin your investment journey!"
    };
    const holdingsString = holdingsArray.map(h => `${h.amount.toFixed(4)} ${h.coin.symbol.toUpperCase()}`).join(', ');
    const usdtBalance = portfolio.usdtBalance.toFixed(2);
    const promptText = `
    Act as a friendly and insightful crypto portfolio analyst for a beginner investor.
    Analyze the following crypto portfolio and provide a detailed, actionable analysis.
    Portfolio Holdings: ${holdingsString}
    Cash Balance (USDT): $${usdtBalance}
    Your analysis must be structured and concise. Focus on being educational and helpful, not just giving direct financial advice.
    Provide your output in JSON format with the following structure:
    - "overallAssessment": A brief, one-sentence summary of the portfolio's current state.
    - "riskScore": A numerical risk score from 1 (very low risk) to 10 (very high risk).
    - "riskAnalysis": Identify the primary risks. Go beyond just concentration. Mention volatility risk if holding many altcoins, or lack of growth potential if holding only stablecoins.
    - "diversification": Provide a specific suggestion for diversification into a different sector (e.g., DeFi, Gaming, Infrastructure) and give one or two coin examples.
    - "rebalancingOpportunities": Suggest a concrete rebalancing action. For example: "Consider selling 0.1 BTC (approx. $XXXX) and using the proceeds to buy 1 ETH to improve your Layer-1 diversification." Be specific about an action.
    - "positiveNote": Find something positive to say about the portfolio. For example, "Holding a blue-chip asset like Bitcoin is a great foundation."
    `;
    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash", contents: promptText,
            config: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: Type.OBJECT,
                    properties: {
                        overallAssessment: { type: Type.STRING }, riskScore: { type: Type.INTEGER },
                        riskAnalysis: { type: Type.STRING }, diversification: { type: Type.STRING },
                        rebalancingOpportunities: { type: Type.STRING }, positiveNote: { type: Type.STRING }
                    },
                    required: ["overallAssessment", "riskScore", "riskAnalysis", "diversification", "rebalancingOpportunities", "positiveNote"]
                }
            }
        });
        return JSON.parse(response.text.trim());
    } catch (error) {
        console.error("Error fetching portfolio analysis:", error);
        return { overallAssessment: "Could not generate AI portfolio analysis due to an error." };
    }
};

const getTrendPrediction = async (coinName, historicalData) => {
    if (!ai) return { trend: 'Neutral', confidence: 60, analysis: 'AI analysis is unavailable.' };
    const simplifiedData = historicalData.slice(-30).map(d => ({ date: new Date(d[0]).toLocaleDateString(), price: d[1].toFixed(2) }));
    const promptText = `
    Act as a financial analyst specializing in cryptocurrency time-series analysis.
    You are given the last 30 days of price data for ${coinName}. Data: ${JSON.stringify(simplifiedData)}
    Based on this data, perform a simplified trend analysis. Predict the short-term price trend for the next 7 days.
    Provide your output in JSON format with the following structure:
    - "trend": a string, either "Bullish", "Bearish", or "Neutral".
    - "confidence": an integer between 0 and 100, representing your confidence in this prediction.
    - "analysis": a brief, one-sentence explanation for your prediction based on the data provided.
    `;
    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash", contents: promptText,
            config: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: Type.OBJECT,
                    properties: {
                        trend: { type: Type.STRING, enum: ["Bullish", "Bearish", "Neutral"] },
                        confidence: { type: Type.INTEGER }, analysis: { type: Type.STRING }
                    }, required: ["trend", "confidence", "analysis"]
                }
            }
        });
        return JSON.parse(response.text.trim());
    } catch (error) {
        console.error(`Error fetching trend prediction for ${coinName}:`, error);
        throw error;
    }
};

const getAIRecommendations = async (coins, fearAndGreedValue) => {
    const mockRecommendations = [
      { coinId: 'bitcoin', coinName: 'Bitcoin', score: 82, recommendation: 'Strong Buy', reasoning: 'Strong fundamentals and increasing institutional adoption (mock data).', scoreBreakdown: { trend: 30, sentiment: 20, fundamentals: 18, technology: 9, mood: 5 } },
      { coinId: 'ethereum', coinName: 'Ethereum', score: 65, recommendation: 'Hold', reasoning: 'Solid ecosystem but facing competition and scalability challenges (mock data).', scoreBreakdown: { trend: 22, sentiment: 15, fundamentals: 15, technology: 9, mood: 4 } },
    ];
    if (!ai || coins.length === 0) return mockRecommendations;
    const topCoinsForAnalysis = coins.slice(0, 10);
    const coinInfoForPrompt = topCoinsForAnalysis.map(c => ({ name: c.name, id: c.id }));
    const promptText = `
    Act as a sophisticated crypto investment analyst for beginners. Analyze: ${topCoinsForAnalysis.map(c => c.name).join(', ')}.
    API IDs: ${JSON.stringify(coinInfoForPrompt)}.
    The final score (0-100) is a weighted average: Market Trend (35%), Fundamentals (20%), Sentiment (20%), Technology (15%), Market Mood (10%).
    Current Fear & Greed Index is ${fearAndGreedValue} (0=Fear, 100=Greed). Use this for "Market Mood".
    For each coin, provide: "coinId", "coinName", a final score, a breakdown of scores for each factor (sum must equal total), a recommendation ('Strong Buy', 'Buy', 'Hold', 'Risky', 'Sell'), and a one-sentence reasoning.
    Return a JSON array of objects.
    `;
    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash", contents: promptText,
            config: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: Type.ARRAY,
                    items: {
                        type: Type.OBJECT,
                        properties: {
                            coinId: { type: Type.STRING }, coinName: { type: Type.STRING }, score: { type: Type.INTEGER },
                            recommendation: { type: Type.STRING }, reasoning: { type: Type.STRING },
                            scoreBreakdown: {
                                type: Type.OBJECT,
                                properties: {
                                    trend: { type: Type.INTEGER }, sentiment: { type: Type.INTEGER },
                                    fundamentals: { type: Type.INTEGER }, technology: { type: Type.INTEGER },
                                    mood: { type: Type.INTEGER },
                                }, required: ["trend", "sentiment", "fundamentals", "technology", "mood"],
                            },
                        }, required: ["coinId", "coinName", "score", "recommendation", "reasoning", "scoreBreakdown"],
                    },
                },
            },
        });
        const recommendations = JSON.parse(response.text.trim());
        const validCoinIds = new Set(topCoinsForAnalysis.map(c => c.id));
        const filteredRecs = recommendations.filter(rec => validCoinIds.has(rec.coinId));
        return filteredRecs.length > 0 ? filteredRecs : mockRecommendations;
    } catch (error) {
        console.error("Error fetching AI recommendations:", error);
        return mockRecommendations;
    }
};

const getAIComparison = async (coins) => {
    if (!ai) return "AI analysis is currently unavailable.";
    if (coins.length < 2) return "Please select at least two coins for comparison.";
    const coinNames = coins.map(c => c.name).join(', ');
    const promptText = `
    Act as a crypto analyst for beginners.
    Provide a concise, one-paragraph comparison of: ${coinNames}.
    Focus on their primary use case, fundamentals, and recent developer activity.
    Highlight one key strength for each coin.
    For example: "While Bitcoin serves as a digital store of value with the strongest security, Ethereum offers a robust platform for decentralized applications with high developer activity. Solana competes with higher transaction speeds but has faced network stability challenges."
    `;
    try {
        const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: promptText });
        return response.text;
    } catch (error) {
        console.error("Error fetching AI comparison:", error);
        return "Could not generate AI comparison at this time.";
    }
};

//========= From services/cryptoPanicApi.ts =========//
const CRYPTO_PANIC_API_KEY = process.env.CRYPTO_PANIC_API_KEY;

const mapCryptoPanicResponse = (results) => {
    return results.map((article) => {
        const bullishVotes = article.votes.bullish || 0;
        const bearishVotes = article.votes.bearish || 0;
        let sentiment = 'Neutral';
        if (bullishVotes > bearishVotes * 1.1) sentiment = 'Bullish';
        else if (bearishVotes > bullishVotes * 1.1) sentiment = 'Bearish';
        return { id: article.id.toString(), title: article.title, source: article.source.title, url: article.url, sentiment };
    });
};

const getCoinNews = async (coinSymbol) => {
    const mockNewsData = {
      btc: [{ id: 'btc1', title: 'Bitcoin Hits New All-Time High Amidst Strong ETF Inflows', source: 'CryptoPanic', url: '#', sentiment: 'Bullish' }],
      eth: [{ id: 'eth1', title: 'Ethereum "Pectra" Upgrade Details Revealed, Focus on User Experience', source: 'Decrypt', url: '#', sentiment: 'Bullish' }],
      default: [{ id: 'gen1', title: 'Crypto Market Cap Reaches $2.5 Trillion as Altcoins Rally', source: 'CryptoPanic', url: '#', sentiment: 'Bullish' }],
    };
    if (!CRYPTO_PANIC_API_KEY) {
        console.warn("CryptoPanic API key not found. Using mock news data.");
        return mockNewsData[coinSymbol.toLowerCase()] || mockNewsData.default;
    }
    try {
        const response = await fetch(`https://cors.eu.org/https://cryptopanic.com/api/v1/posts/?auth_token=${CRYPTO_PANIC_API_KEY}&currencies=${coinSymbol.toUpperCase()}&public=true`);
        if (!response.ok) throw new Error(`CryptoPanic API request failed with status ${response.status}`);
        const data = await response.json();
        return mapCryptoPanicResponse(data.results);
    } catch (error) {
        console.error(`Error fetching news for ${coinSymbol}:`, error);
        return mockNewsData[coinSymbol.toLowerCase()] || mockNewsData.default;
    }
};

//========= From services/mockApi.ts =========//
const getLatestNews = async () => {
  const fallbackNews = [
      { id: '1', title: 'Bitcoin ETF inflows reach new high as institutional interest surges.', source: 'CryptoPanic', url: '#', sentiment: 'Bullish' },
      { id: '2', title: 'Ethereum\'s next upgrade "Pectra" targets scalability improvements.', source: 'CoinDesk', url: '#', sentiment: 'Bullish' },
      { id: '3', title: 'Regulatory uncertainty continues to cast a shadow over the crypto market.', source: 'Decrypt', url: '#', sentiment: 'Bearish' },
      { id: '4', title: 'Solana DeFi ecosystem sees rapid growth, but faces network stability questions.', source: 'The Block', url: '#', sentiment: 'Neutral' },
  ];
  if (!CRYPTO_PANIC_API_KEY) {
    console.warn("CryptoPanic API key not found. Using cached news data for dashboard.");
    return fallbackNews;
  }
  try {
    const response = await fetch(`https://cors.eu.org/https://cryptopanic.com/api/v1/posts/?auth_token=${CRYPTO_PANIC_API_KEY}&public=true`);
    if (!response.ok) throw new Error(`API Error: ${response.status}`);
    const data = await response.json();
    return mapCryptoPanicResponse(data.results.slice(0, 4));
  } catch (error) {
    console.error("Error fetching latest news from CryptoPanic:", error);
    return fallbackNews;
  }
};

//========= From services/messariApi.ts =========//
const getFundamentalData = async (coinSymbol) => {
    try {
        const response = await fetch(`https://cors.eu.org/https://data.messari.io/api/v2/assets/${coinSymbol.toLowerCase()}/profile`);
        if (!response.ok) throw new Error(`Messari API request failed with status ${response.status}`);
        const json = await response.json();
        if (json.status.error_code || !json.data) throw new Error(json.status.error_message || "Invalid data from Messari");
        const profile = json.data?.profile;
        const getText = (data, fallback = "Information not available.") => typeof data === 'string' && data.trim() !== '' ? data.trim() : fallback;
        const formatTeam = (contributors) => {
            if (!contributors) return "Team information not available.";
            const individuals = contributors.individuals?.map(p => `${p.first_name} ${p.last_name}`.trim()).join(', ');
            const organizations = contributors.organizations?.map(o => o.name).join(', ');
            if (individuals && organizations) return `Key individuals: ${individuals}. Key organizations: ${organizations}.`;
            return individuals || organizations || "Public team information not available.";
        };
        return {
            background: getText(profile?.general?.overview?.project_details),
            tokenomics: getText(profile?.token_details?.usage?.token_usage_details),
            team: formatTeam(profile?.general?.contributors)
        };
    } catch (error) {
        console.error(`Error fetching fundamentals for ${coinSymbol} from Messari:`, error);
        throw error;
    }
};

//========= CONTEXT PROVIDERS =========//
const ThemeContext = React.createContext();
const PortfolioContext = React.createContext();
const FavoritesContext = React.createContext();
const AlertsContext = React.createContext();
const NotificationsContext = React.createContext();
const DAppContext = React.createContext();

const useTheme = () => React.useContext(ThemeContext);
const usePortfolio = () => React.useContext(PortfolioContext);
const useFavorites = () => React.useContext(FavoritesContext);
const useAlerts = () => React.useContext(AlertsContext);
const useNotifications = () => React.useContext(NotificationsContext);
const useDApp = () => React.useContext(DAppContext);

const ThemeProvider = ({ children }) => {
    const getInitialTheme = () => {
        if (typeof window !== 'undefined' && window.localStorage) {
            const storedPrefs = window.localStorage.getItem('theme');
            if (storedPrefs) return storedPrefs;
            if (window.matchMedia('(prefers-color-scheme: dark)').matches) return 'dark';
        }
        return 'dark';
    };
    const [theme, setTheme] = React.useState(getInitialTheme);
    React.useEffect(() => {
        const root = window.document.documentElement;
        root.classList.remove(theme === 'dark' ? 'light' : 'dark');
        root.classList.add(theme);
        localStorage.setItem('theme', theme);
    }, [theme]);
    const toggleTheme = () => setTheme(prev => (prev === 'light' ? 'dark' : 'light'));
    return <ThemeContext.Provider value={{ theme, toggleTheme }}>{children}</ThemeContext.Provider>;
};

const PortfolioProvider = ({ children }) => {
    const INITIAL_BALANCE = 1000;
    const [portfolio, setPortfolio] = React.useState(() => {
        try {
            const saved = localStorage.getItem('cryptoPortfolio');
            const parsed = saved ? JSON.parse(saved) : null;
            return parsed ? { ...parsed, limitOrders: parsed.limitOrders || [] } : 
                { usdtBalance: INITIAL_BALANCE, holdings: {}, transactions: [], initialBalance: INITIAL_BALANCE, limitOrders: [] };
        } catch (error) {
            return { usdtBalance: INITIAL_BALANCE, holdings: {}, transactions: [], initialBalance: INITIAL_BALANCE, limitOrders: [] };
        }
    });
    React.useEffect(() => {
        localStorage.setItem('cryptoPortfolio', JSON.stringify(portfolio));
    }, [portfolio]);
    const buyCoin = (coin, amount, price, isSilent = false) => {
        const totalCost = amount * price;
        const fee = totalCost * TRADING_FEE_RATE;
        const totalCostWithFee = totalCost + fee;
        if (portfolio.usdtBalance < totalCostWithFee) {
            if (!isSilent) alert("Insufficient funds (including 0.1% fee)!");
            return false;
        }
        setPortfolio(prev => {
            const newHoldings = { ...prev.holdings };
            const existing = prev.holdings[coin.id];
            if (existing) {
                const totalAmount = existing.amount + amount;
                const totalSpent = (existing.avgBuyPrice * existing.amount) + totalCostWithFee;
                newHoldings[coin.id] = { ...existing, amount: totalAmount, avgBuyPrice: totalSpent / totalAmount };
            } else {
                newHoldings[coin.id] = { coin, amount, avgBuyPrice: price * (1 + TRADING_FEE_RATE) };
            }
            const newTx = { id: `txn_${Date.now()}`, type: 'buy', coin, amount, price, fee, total: totalCostWithFee, date: new Date().toISOString() };
            return { ...prev, usdtBalance: prev.usdtBalance - totalCostWithFee, holdings: newHoldings, transactions: [newTx, ...prev.transactions] };
        });
        return true;
    };
    const sellCoin = (coin, amount, price, isSilent = false) => {
        const holding = portfolio.holdings[coin.id];
        if (!holding || holding.amount < amount) {
            if (!isSilent) alert("Not enough coins to sell!");
            return false;
        }
        const totalRevenue = amount * price;
        const fee = totalRevenue * TRADING_FEE_RATE;
        const revenueAfterFee = totalRevenue - fee;
        const costBasis = amount * holding.avgBuyPrice;
        const realizedPnl = revenueAfterFee - costBasis;
        setPortfolio(prev => {
            const newHoldings = { ...prev.holdings };
            const existing = newHoldings[coin.id];
            if (existing.amount - amount < 1e-6) {
                delete newHoldings[coin.id];
            } else {
                newHoldings[coin.id] = { ...existing, amount: existing.amount - amount };
            }
            const newTx = { id: `txn_${Date.now()}`, type: 'sell', coin, amount, price, fee, total: revenueAfterFee, pnl: realizedPnl, date: new Date().toISOString() };
            return { ...prev, usdtBalance: prev.usdtBalance + revenueAfterFee, holdings: newHoldings, transactions: [newTx, ...prev.transactions] };
        });
        return true;
    };
    const placeLimitOrder = (type, coin, amount, limitPrice, isSilent = false) => {
        if (type === 'buy' && portfolio.usdtBalance < (amount * limitPrice) * (1 + TRADING_FEE_RATE)) {
            if (!isSilent) alert("Insufficient USDT for limit order (including 0.1% fee).");
            return false;
        } else if (type === 'sell' && (!portfolio.holdings[coin.id] || portfolio.holdings[coin.id].amount < amount)) {
            if (!isSilent) alert("Insufficient holdings for limit order.");
            return false;
        }
        const newOrder = { id: `limit_${Date.now()}`, type, coin, amount, limitPrice, status: 'open', createdAt: new Date().toISOString() };
        setPortfolio(prev => ({ ...prev, limitOrders: [newOrder, ...prev.limitOrders] }));
        return true;
    };
    const cancelLimitOrder = (orderId) => setPortfolio(prev => ({ ...prev, limitOrders: prev.limitOrders.map(o => o.id === orderId ? { ...o, status: 'cancelled' } : o) }));
    const updateLimitOrderStatus = (orderId, status) => setPortfolio(prev => ({ ...prev, limitOrders: prev.limitOrders.map(o => o.id === orderId ? { ...o, status } : o) }));
    
    return <PortfolioContext.Provider value={{ portfolio, buyCoin, sellCoin, placeLimitOrder, cancelLimitOrder, updateLimitOrderStatus }}>{children}</PortfolioContext.Provider>;
};

const FavoritesProvider = ({ children }) => {
  const [favoriteCoinIds, setFavoriteCoinIds] = React.useState(() => {
    try {
      return JSON.parse(localStorage.getItem('cryptoFavorites') || '[]');
    } catch { return []; }
  });
  React.useEffect(() => {
    localStorage.setItem('cryptoFavorites', JSON.stringify(favoriteCoinIds));
  }, [favoriteCoinIds]);
  const addFavorite = React.useCallback(coinId => setFavoriteCoinIds(prev => prev.includes(coinId) ? prev : [...prev, coinId]), []);
  const removeFavorite = React.useCallback(coinId => setFavoriteCoinIds(prev => prev.filter(id => id !== coinId)), []);
  const isFavorite = React.useCallback(coinId => favoriteCoinIds.includes(coinId), [favoriteCoinIds]);
  return <FavoritesContext.Provider value={{ favoriteCoinIds, addFavorite, removeFavorite, isFavorite }}>{children}</FavoritesContext.Provider>;
};

const AlertsProvider = ({ children }) => {
  const [alerts, setAlerts] = React.useState(() => {
    try {
      return JSON.parse(localStorage.getItem('cryptoAlerts') || '[]');
    } catch { return []; }
  });
  React.useEffect(() => {
    localStorage.setItem('cryptoAlerts', JSON.stringify(alerts));
  }, [alerts]);
  const addAlert = React.useCallback(alertData => {
    const newAlert = { ...alertData, id: `alert_${Date.now()}`, status: 'active', createdAt: new Date().toISOString() };
    setAlerts(prev => [newAlert, ...prev]);
  }, []);
  const removeAlert = React.useCallback(alertId => setAlerts(prev => prev.filter(a => a.id !== alertId)), []);
  const updateAlertStatus = React.useCallback((alertId, status) => setAlerts(prev => prev.map(a => a.id === alertId ? { ...a, status } : a)), []);
  return <AlertsContext.Provider value={{ alerts, addAlert, removeAlert, updateAlertStatus }}>{children}</AlertsContext.Provider>;
};

const NotificationsProvider = ({ children }) => {
    const [notifications, setNotifications] = React.useState([]);
    const addNotification = React.useCallback((notificationData) => {
        const newNotification = { ...notificationData, id: notificationData.id || `notif_${Date.now()}`, timestamp: new Date().toISOString() };
        setNotifications(prev => [newNotification, ...prev]);
    }, []);
    const removeNotification = React.useCallback(id => setNotifications(prev => prev.filter(n => n.id !== id)), []);
    return <NotificationsContext.Provider value={{ notifications, addNotification, removeNotification }}>{children}</NotificationsContext.Provider>;
};

const DAppProvider = ({ children }) => {
    const [coins, setCoins] = React.useState([]);
    const [loading, setLoading] = React.useState(true);
    const [error, setError] = React.useState(null);
    const [fearAndGreed, setFearAndGreed] = React.useState(null);
    const [dailySummary, setDailySummary] = React.useState(null);
    const { portfolio, buyCoin, sellCoin, updateLimitOrderStatus } = usePortfolio();
    const { favoriteCoinIds } = useFavorites();
    const { alerts, updateAlertStatus } = useAlerts();
    const { addNotification } = useNotifications();
    const uniqueCoinIdsInPortfolio = React.useMemo(() => Object.keys(portfolio.holdings), [portfolio.holdings]);

    const fetchData = React.useCallback(async (isInitialLoad = false) => {
        if (isInitialLoad) setLoading(true);
        setError(null);
        try {
            const promises = [getTopCoins(20), getFearAndGreedIndex()];
            if (isInitialLoad) promises.push(getDailySummary());
            const [topCoins, fearAndGreedData, summaryData] = await Promise.all(promises);
            setFearAndGreed(fearAndGreedData);
            if (summaryData) setDailySummary(summaryData);
            const topCoinIds = new Set(topCoins.map(c => c.id));
            const additionalIds = [...new Set([...uniqueCoinIdsInPortfolio, ...favoriteCoinIds])].filter(id => !topCoinIds.has(id));
            const additionalCoins = additionalIds.length > 0 ? await getCoinsByIds(additionalIds) : [];
            const allCoinsMap = new Map();
            [...topCoins, ...additionalCoins].forEach(c => allCoinsMap.set(c.id, c));
            setCoins(Array.from(allCoinsMap.values()).sort((a,b) => b.market_cap - a.market_cap));
        } catch (err) {
            setError(err.message || 'Failed to load crypto data.');
        } finally {
            if (isInitialLoad) setLoading(false);
        }
    }, [uniqueCoinIdsInPortfolio, favoriteCoinIds]);

    React.useEffect(() => {
        fetchData(true);
        const interval = setInterval(() => fetchData(false), 5 * 60 * 1000);
        return () => clearInterval(interval);
    }, [fetchData]);

    React.useEffect(() => { // Price Alert Checker
        if (!coins.length || !alerts.length) return;
        const activeAlerts = alerts.filter(a => a.status === 'active');
        if (!activeAlerts.length) return;
        const coinPriceMap = new Map(coins.map(c => [c.id, c.current_price]));
        activeAlerts.forEach(alert => {
            const currentPrice = coinPriceMap.get(alert.coinId);
            if (currentPrice === undefined) return;
            const shouldTrigger = (alert.condition === 'above' && currentPrice > alert.targetPrice) || (alert.condition === 'below' && currentPrice < alert.targetPrice);
            if (shouldTrigger) {
                const coin = coins.find(c => c.id === alert.coinId);
                addNotification({ type: 'alert', message: `${coin?.name || alert.coinId} is ${alert.condition} $${alert.targetPrice.toLocaleString()}! Now: $${currentPrice.toLocaleString()}` });
                updateAlertStatus(alert.id, 'triggered');
            }
        });
    }, [coins, alerts, addNotification, updateAlertStatus]);
    
    React.useEffect(() => { // Limit Order Processor
        if (!coins.length || !portfolio.limitOrders.length) return;
        const openOrders = portfolio.limitOrders.filter(o => o.status === 'open');
        if (!openOrders.length) return;
        const coinPriceMap = new Map(coins.map(c => [c.id, c.current_price]));
        openOrders.forEach(order => {
            const currentPrice = coinPriceMap.get(order.coin.id);
            if (currentPrice === undefined) return;
            const shouldFill = (order.type === 'buy' && currentPrice <= order.limitPrice) || (order.type === 'sell' && currentPrice >= order.limitPrice);
            if (shouldFill) {
                const { type, coin, amount, limitPrice } = order;
                const success = type === 'buy' ? buyCoin(coin, amount, limitPrice, true) : sellCoin(coin, amount, limitPrice, true);
                if (success) {
                    updateLimitOrderStatus(order.id, 'filled');
                    addNotification({ type: 'info', message: `Limit ${type} for ${amount.toFixed(4)} ${coin.symbol.toUpperCase()} at $${limitPrice.toLocaleString()} filled!` });
                } else {
                    updateLimitOrderStatus(order.id, 'cancelled');
                    addNotification({ type: 'error', message: `Limit ${type} for ${coin.symbol.toUpperCase()} failed and was cancelled.` });
                }
            }
        });
    }, [coins, portfolio.limitOrders, buyCoin, sellCoin, updateLimitOrderStatus, addNotification]);

    return <DAppContext.Provider value={{ coins, loading, error, fearAndGreed, dailySummary }}>{children}</DAppContext.Provider>;
};

//========= COMPONENTS =========//

const ThemeToggle = () => {
    const { theme, toggleTheme } = useTheme();
    return (
        <button onClick={toggleTheme} className="flex items-center justify-center md:justify-start w-full p-3 my-2 text-gray-500 dark:text-gray-400 rounded-lg transition-colors duration-200 hover:bg-gray-200 dark:hover:bg-gray-700 hover:text-gray-900 dark:hover:text-white" aria-label={`Switch to ${theme === 'light' ? 'dark' : 'light'} mode`}>
            {theme === 'light' ? ( <><i className="fas fa-moon w-6 text-center text-lg"></i><span className="hidden md:inline md:ml-4 font-medium">Dark Mode</span></> ) : 
                                  ( <><i className="fas fa-sun w-6 text-center text-lg"></i><span className="hidden md:inline md:ml-4 font-medium">Light Mode</span></> )}
        </button>
    );
};

const Sidebar = ({ activePage, setActivePage }) => {
    const NavItem = ({ iconClass, label, isActive, onClick }) => (
        <li>
            <button onClick={onClick} className={`flex items-center justify-center md:justify-start w-full p-3 my-2 text-gray-500 dark:text-gray-400 rounded-lg transition-all duration-200 hover:bg-gray-200 dark:hover:bg-gray-700 hover:text-gray-900 dark:hover:text-white ${isActive ? 'bg-primary text-white' : ''}`}>
                <i className={`fas ${iconClass} w-6 text-center text-lg`}></i>
                <span className="hidden md:inline md:ml-4 font-medium">{label}</span>
            </button>
        </li>
    );
    const navItems = [
        { label: 'Dashboard', icon: 'fa-chart-pie' }, { label: 'Portfolio', icon: 'fa-wallet' },
        { label: 'Recommendations', icon: 'fa-lightbulb' }, { label: 'Alerts', icon: 'fa-bell' },
        { label: 'Compare', icon: 'fa-scale-balanced' }, { label: 'Learning Center', icon: 'fa-book-open' },
    ];
    return (
        <aside className="fixed top-0 left-0 h-full w-16 md:w-64 bg-gray-100 dark:bg-gray-800 p-2 md:p-4 shadow-lg z-10 transition-all duration-300 flex flex-col">
            <div>
                <div className="flex items-center justify-center md:justify-start mb-10">
                    <i className="fas fa-rocket text-primary text-3xl"></i>
                    <h1 className="hidden md:inline text-xl font-bold ml-2 text-gray-900 dark:text-white">Crypto Helper</h1>
                </div>
                <nav><ul>{navItems.map(item => <NavItem key={item.label} iconClass={item.icon} label={item.label} isActive={activePage === item.label} onClick={() => setActivePage(item.label)} />)}</ul></nav>
            </div>
            <div className="mt-auto"><ThemeToggle /></div>
        </aside>
    );
};

const CoinCard = ({ coin, onClick }) => {
  const { isFavorite, addFavorite, removeFavorite } = useFavorites();
  const [isAnimating, setIsAnimating] = React.useState(false);
  const isPositive = coin.price_change_percentage_24h >= 0;
  const isFav = isFavorite(coin.id);
  const handleFavoriteToggle = (e) => {
    e.stopPropagation();
    if (isAnimating) return;
    if (!isFav) {
      setIsAnimating(true);
      setTimeout(() => setIsAnimating(false), 400);
    }
    isFav ? removeFavorite(coin.id) : addFavorite(coin.id);
  };
  return (
    <button onClick={onClick} disabled={!onClick} className={`bg-white dark:bg-gray-700 p-4 rounded-lg shadow-md hover:bg-gray-100 dark:hover:bg-gray-600 transition-all duration-200 w-full text-left disabled:cursor-not-allowed relative border-2 ${isFav ? 'border-yellow-400' : 'border-transparent'}`} aria-label={`View details for ${coin.name}`}>
      <button onClick={handleFavoriteToggle} className={`absolute top-2 right-2 text-xl z-10 p-1 rounded-full hover:bg-gray-200/50 dark:hover:bg-gray-500/50 transition-colors ${isFav ? 'text-yellow-400' : 'text-gray-400 dark:text-gray-500'}`} aria-label={isFav ? `Remove ${coin.name} from favorites` : `Add ${coin.name} to favorites`}>
        <i className={`${isFav ? 'fas' : 'far'} fa-star ${isAnimating ? 'animate-favorite-pop' : ''}`}></i>
      </button>
      <div className="flex items-center mb-2">
        <img src={coin.image} alt={coin.name} className="w-8 h-8 mr-3" />
        <div>
          <h3 className="font-bold text-lg text-gray-900 dark:text-white">{coin.name}</h3>
          <p className="text-sm text-gray-500 dark:text-gray-400">{coin.symbol.toUpperCase()}</p>
        </div>
      </div>
      <div className="text-right">
        <p className="text-xl font-semibold mb-1 text-gray-900 dark:text-white">${coin.current_price.toLocaleString()}</p>
        <span className={`inline-flex items-center px-2.5 py-1 rounded-full text-sm font-semibold text-white ${isPositive ? 'bg-success' : 'bg-danger'}`}>
          {isPositive ? '▲' : '▼'} {coin.price_change_percentage_24h.toFixed(2)}%
        </span>
      </div>
    </button>
  );
};

const NewsCard = ({ article }) => {
  const sentimentColor =
    article.sentiment === 'Bullish' ? 'bg-green-100 text-green-700 dark:bg-green-500/20 dark:text-green-400' :
    article.sentiment === 'Bearish' ? 'bg-red-100 text-red-700 dark:bg-red-500/20 dark:text-red-400' :
    'bg-gray-200 text-gray-700 dark:bg-gray-500/20 dark:text-gray-400';
  return (
    <a href={article.url} target="_blank" rel="noopener noreferrer" className="block p-3 bg-white dark:bg-gray-700 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors duration-200">
      <div className="flex justify-between items-start">
        <div>
          <p className="font-medium text-gray-800 dark:text-gray-200">{article.title}</p>
          <p className="text-sm text-gray-500 dark:text-gray-400">{article.source}</p>
        </div>
        <span className={`text-xs font-semibold px-2 py-1 rounded-full ${sentimentColor}`}>{article.sentiment}</span>
      </div>
    </a>
  );
};

const FearGreedIndex = ({ value, classification }) => {
  const rotation = (value / 100) * 180 - 90;
  const getColor = val => {
    if (val <= 25) return '#ef4444'; if (val <= 45) return '#f97316'; if (val <= 55) return '#eab308';
    if (val <= 75) return '#84cc16'; return '#22c55e';
  };
  const color = getColor(value);
  return (
    <div className="flex flex-col items-center p-4">
      <div className="relative w-48 h-24 overflow-hidden mb-2">
        <div className="absolute top-0 left-0 w-full h-full border-t-8 border-l-8 border-r-8 border-gray-300 dark:border-gray-600 rounded-t-full" style={{borderTopLeftRadius: '100px', borderTopRightRadius: '100px'}}></div>
        <div className="absolute bottom-0 left-1/2 w-2 h-20 bg-gray-600 dark:bg-gray-200 rounded-t-full origin-bottom transform -translate-x-1/2" style={{ transform: `translateX(-50%) rotate(${rotation}deg)` }}></div>
        <div className="absolute bottom-0 left-1/2 w-4 h-4 bg-gray-600 dark:bg-gray-200 rounded-full transform -translate-x-1/2 translate-y-1/2"></div>
      </div>
      <p className="text-4xl font-bold" style={{ color }}>{value}</p>
      <p className="text-lg font-semibold" style={{ color }}>{classification}</p>
      <div className="w-full flex justify-between text-xs text-gray-500 dark:text-gray-400 mt-1 px-2">
        <span>Fear</span><span>Neutral</span><span>Greed</span>
      </div>
    </div>
  );
};

// =========================================================================
// ========= ALL OTHER COMPONENTS PASTED HERE FOR CONSOLIDATION ============
// =========================================================================

const TradeModal = ({ coin, tradeType, onClose }) => {
  const { portfolio, buyCoin, sellCoin, placeLimitOrder } = usePortfolio();
  const [orderType, setOrderType] = React.useState('market');
  const [amount, setAmount] = React.useState('');
  const [limitPrice, setLimitPrice] = React.useState('');
  const [subTotal, setSubTotal] = React.useState(0);
  const [fee, setFee] = React.useState(0);

  const holding = portfolio.holdings[coin.id];
  const maxAmount = tradeType === 'buy'
    ? portfolio.usdtBalance / (coin.current_price * (1 + TRADING_FEE_RATE))
    : (holding ? holding.amount : 0);

  React.useEffect(() => {
    const numericAmount = parseFloat(amount);
    let currentSubtotal = 0;
    if (!isNaN(numericAmount) && numericAmount > 0) {
      if (orderType === 'market') {
        currentSubtotal = numericAmount * coin.current_price;
      } else {
        const numericLimitPrice = parseFloat(limitPrice);
        if (!isNaN(numericLimitPrice) && numericLimitPrice > 0) {
            currentSubtotal = numericAmount * numericLimitPrice;
        }
      }
    }
    setSubTotal(currentSubtotal);
    setFee(currentSubtotal * TRADING_FEE_RATE);
  }, [amount, limitPrice, orderType, coin.current_price]);
  
  const finalTotal = tradeType === 'buy' ? subTotal + fee : subTotal - fee;

  const handleAmountChange = (e) => {
    const value = e.target.value;
    if (/^\d*\.?\d*$/.test(value)) { // Allow only numbers and one dot
      setAmount(value);
    }
  };

  const handleLimitPriceChange = (e) => {
    const value = e.target.value;
    if (/^\d*\.?\d*$/.test(value)) {
      setLimitPrice(value);
    }
  };
  
  const handleMaxClick = () => {
    setAmount(parseFloat(maxAmount.toFixed(8)).toString());
  }

  const handleSubmit = (e) => {
    e.preventDefault();
    const numericAmount = parseFloat(amount);
    if (isNaN(numericAmount) || numericAmount <= 0) {
      alert("Please enter a valid amount.");
      return;
    }
    
    if (orderType === 'market') {
        let success = false;
        if (tradeType === 'buy') {
          success = buyCoin(coin, numericAmount, coin.current_price);
        } else {
          success = sellCoin(coin, numericAmount, coin.current_price);
        }
        if (success) onClose();
    } else { // Limit order
        const numericLimitPrice = parseFloat(limitPrice);
        if (isNaN(numericLimitPrice) || numericLimitPrice <= 0) {
            alert("Please enter a valid limit price.");
            return;
        }
        const success = placeLimitOrder(tradeType, coin, numericAmount, numericLimitPrice);
        if (success) onClose();
    }
  };

  const OrderTypeButton = ({ type, label }) => (
      <button
        type="button"
        onClick={() => setOrderType(type)}
        className={`w-full p-2 text-center font-semibold rounded-md transition-colors ${orderType === type ? 'bg-primary text-white' : 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600'}`}
      >
          {label}
      </button>
  );

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md m-4">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold capitalize">{tradeType} {coin.name}</h2>
          <button onClick={onClose} className="text-gray-500 dark:text-gray-400 hover:text-gray-800 dark:hover:text-white text-2xl leading-none">&times;</button>
        </div>

        <div className="grid grid-cols-2 gap-2 mb-4 p-1 bg-gray-100 dark:bg-gray-900 rounded-lg">
            <OrderTypeButton type="market" label="Market" />
            <OrderTypeButton type="limit" label="Limit" />
        </div>

        <form onSubmit={handleSubmit}>
          {orderType === 'limit' && (
            <div className="mb-4">
                <label htmlFor="limitPrice" className="block font-medium text-sm text-gray-500 dark:text-gray-400 mb-1">Limit Price (USD)</label>
                <div className="relative">
                    <span className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400">$</span>
                    <input type="text" id="limitPrice" value={limitPrice} onChange={handleLimitPriceChange} className="w-full bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white p-3 pl-6 rounded-md border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-primary" placeholder="0.00" aria-label="Limit price in USD" />
                </div>
            </div>
          )}

          <div className="mb-4">
            <div className="flex justify-between items-baseline text-sm text-gray-500 dark:text-gray-400 mb-1">
              <label htmlFor="amount" className="font-medium">Amount ({coin.symbol.toUpperCase()})</label>
              <span>{tradeType === 'buy' ? 'Available:' : 'Holding:'} {tradeType === 'buy' ? `$${portfolio.usdtBalance.toFixed(2)}` : `${(holding?.amount || 0).toFixed(6)}`}</span>
            </div>
            <div className="relative">
                <input type="text" id="amount" value={amount} onChange={handleAmountChange} className="w-full bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white p-3 rounded-md border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-primary" placeholder="0.00" aria-label={`Amount in ${coin.symbol.toUpperCase()}`} />
                 <button type="button" onClick={handleMaxClick} className="absolute right-2 top-1/2 -translate-y-1/2 bg-primary text-white text-xs px-2 py-1 rounded hover:bg-blue-500 transition-colors">MAX</button>
            </div>
          </div>
            <div className="space-y-2 text-sm mb-4">
                <div className="flex justify-between items-center text-gray-600 dark:text-gray-300">
                    <span className="flex items-center"><i className="fas fa-tag mr-2 text-primary"></i>Market Price</span>
                    <span className="font-mono font-semibold text-gray-900 dark:text-white">${coin.current_price.toLocaleString()}</span>
                </div>
                <div className="flex justify-between items-center text-gray-600 dark:text-gray-300">
                    <span className="flex items-center">Subtotal</span>
                    <span className="font-mono text-gray-800 dark:text-gray-200">${subTotal.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</span>
                </div>
                <div className="flex justify-between items-center text-gray-600 dark:text-gray-300 relative group">
                    <span className="flex items-center cursor-help">Fee (0.1%)<i className="fas fa-info-circle text-xs ml-1.5 text-gray-400"></i></span>
                    <span className="font-mono text-gray-800 dark:text-gray-200">{tradeType === 'buy' ? '+' : '-'}${fee.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 4})}</span>
                    <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 w-max px-2 py-1 bg-gray-700 dark:bg-gray-900 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">A 0.1% fee is applied to simulate real trading conditions.<div className="absolute top-full left-1/2 -translate-x-1/2 w-0 h-0 border-x-4 border-x-transparent border-t-4 border-t-gray-700 dark:border-t-gray-900"></div></div>
                </div>
            </div>

          <div className="border-t border-gray-200 dark:border-gray-600 my-4"></div>

          <div className="flex justify-between items-center text-xl font-bold mb-6">
            <span className="text-gray-600 dark:text-gray-300">Total</span>
            <span className="font-mono">${finalTotal.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</span>
          </div>
          <button type="submit" className={`w-full p-3 rounded-md font-bold text-white transition-colors ${tradeType === 'buy' ? 'bg-success hover:bg-green-500' : 'bg-danger hover:bg-red-500'}`}>
            {orderType === 'market' ? `Confirm Market ${tradeType}` : `Place Limit ${tradeType} Order` }
          </button>
        </form>
      </div>
    </div>
  );
};

const BuyAssetModal = ({ onClose }) => {
  const { portfolio, buyCoin, placeLimitOrder } = usePortfolio();
  const { coins } = useDApp();
  const [selectedCoinId, setSelectedCoinId] = React.useState('');
  const [inputType, setInputType] = React.useState('usdt');
  const [inputValue, setInputValue] = React.useState('');
  const [orderType, setOrderType] = React.useState('market');
  const [limitPrice, setLimitPrice] = React.useState('');
  
  const selectedCoin = React.useMemo(() => {
      return coins.find(c => c.id === selectedCoinId) || null;
  }, [selectedCoinId, coins]);

  React.useEffect(() => { setInputValue(''); }, [selectedCoinId]);

  const { coinAmount, usdtTotal, fee } = React.useMemo(() => {
    if (!selectedCoin || !inputValue) return { coinAmount: 0, usdtTotal: 0, fee: 0 };
    const numericValue = parseFloat(inputValue);
    if (isNaN(numericValue) || numericValue <= 0) return { coinAmount: 0, usdtTotal: 0, fee: 0 };

    let priceToUse = selectedCoin.current_price;
    if (orderType === 'limit') {
        const numericLimit = parseFloat(limitPrice);
        if (numericLimit > 0) {
            priceToUse = numericLimit;
        } else {
             return { coinAmount: 0, usdtTotal: 0, fee: 0 };
        }
    }
    
    let subtotal = 0;
    let finalCoinAmount = 0;

    if (inputType === 'usdt') {
        subtotal = numericValue;
        finalCoinAmount = priceToUse > 0 ? numericValue / priceToUse : 0;
    } else {
        subtotal = numericValue * priceToUse;
        finalCoinAmount = numericValue;
    }

    const calculatedFee = subtotal * TRADING_FEE_RATE;
    return { coinAmount: finalCoinAmount, usdtTotal: subtotal, fee: calculatedFee };
  }, [inputValue, inputType, selectedCoin, orderType, limitPrice]);

  const finalTotal = usdtTotal + fee;

  const handleInputTypeChange = (newType) => {
    if (inputType !== newType) { setInputValue(''); setInputType(newType); }
  };

  const handleInputChange = (e) => {
    const value = e.target.value;
    if (/^\d*\.?\d*$/.test(value)) { setInputValue(value); }
  };

  const handleLimitPriceChange = (e) => {
    const value = e.target.value;
    if (/^\d*\.?\d*$/.test(value)) {
      setLimitPrice(value);
    }
  };
  
  const handleMaxClick = () => {
    if (!selectedCoin) return;
    let priceToUse = selectedCoin.current_price;
    if (orderType === 'limit') {
        const numericLimit = parseFloat(limitPrice);
        if(numericLimit > 0) priceToUse = numericLimit;
    }
    if (inputType === 'usdt') {
      setInputValue(portfolio.usdtBalance.toFixed(2));
    } else {
      const maxCoin = portfolio.usdtBalance / (priceToUse * (1 + TRADING_FEE_RATE));
      setInputValue(parseFloat(maxCoin.toFixed(8)).toString());
    }
  }

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!selectedCoin) { alert("Please select a coin."); return; }
    if (coinAmount <= 0) { alert("Please enter a valid amount."); return; }

    if (orderType === 'market') {
      const success = buyCoin(selectedCoin, coinAmount, selectedCoin.current_price);
      if (success) { onClose(); }
    } else {
      const numericLimitPrice = parseFloat(limitPrice);
      if (isNaN(numericLimitPrice) || numericLimitPrice <= 0) {
        alert("Please enter a valid limit price.");
        return;
      }
      const success = placeLimitOrder('buy', selectedCoin, coinAmount, numericLimitPrice);
      if (success) { onClose(); }
    }
  };

  const subtext = React.useMemo(() => {
    if (!inputValue || !selectedCoin) return '';
    if (inputType === 'usdt') return `≈ ${coinAmount.toFixed(6)} ${selectedCoin.symbol.toUpperCase()}`;
    return `≈ $${usdtTotal.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
  }, [inputValue, inputType, selectedCoin, coinAmount, usdtTotal]);

  const OrderTypeButton = ({ type, label }) => (
      <button
        type="button"
        onClick={() => setOrderType(type)}
        className={`w-full p-2 text-center font-semibold rounded-md transition-colors ${orderType === type ? 'bg-primary text-white' : 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600'}`}
      >
          {label}
      </button>
  );

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md m-4">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold">Buy New Asset</h2>
          <button onClick={onClose} className="text-gray-500 dark:text-gray-400 hover:text-gray-800 dark:hover:text-white text-2xl leading-none">&times;</button>
        </div>
        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label htmlFor="coin" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Select Coin</label>
            <select id="coin" value={selectedCoinId} onChange={(e) => setSelectedCoinId(e.target.value)} className="w-full bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white p-3 rounded-md border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-primary">
                <option value="" disabled>-- Choose a cryptocurrency --</option>
                {coins.map(coin => (<option key={coin.id} value={coin.id}>{coin.name} ({coin.symbol.toUpperCase()})</option>))}
            </select>
          </div>
          {selectedCoin && (<>
              <div className="grid grid-cols-2 gap-2 mb-4 p-1 bg-gray-100 dark:bg-gray-900 rounded-lg">
                <OrderTypeButton type="market" label="Market" />
                <OrderTypeButton type="limit" label="Limit" />
              </div>

              {orderType === 'limit' && (
                <div className="mb-4">
                    <label htmlFor="limitPrice" className="block font-medium text-sm text-gray-500 dark:text-gray-400 mb-1">Limit Price (USD)</label>
                    <div className="relative">
                        <span className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400">$</span>
                        <input type="text" id="limitPrice" value={limitPrice} onChange={handleLimitPriceChange} className="w-full bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white p-3 pl-6 rounded-md border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-primary" placeholder="0.00" aria-label="Limit price in USD" />
                    </div>
                </div>
              )}

              <div className="mb-4">
                <div className="flex items-center space-x-2 mb-2">
                    <button type="button" onClick={() => handleInputTypeChange('usdt')} className={`px-3 py-1 text-sm rounded-md transition-colors ${inputType === 'usdt' ? 'bg-primary text-white' : 'bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600'}`}>Buy in USDT</button>
                    <button type="button" onClick={() => handleInputTypeChange('coin')} className={`px-3 py-1 text-sm rounded-md transition-colors ${inputType === 'coin' ? 'bg-primary text-white' : 'bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600'}`}>Buy in {selectedCoin.symbol.toUpperCase()}</button>
                </div>
                <div className="flex justify-between items-baseline text-sm text-gray-500 dark:text-gray-400 mb-1">
                  <label htmlFor="amount" className="font-medium">Amount</label>
                  <span>Balance: {portfolio.usdtBalance.toFixed(2)} USDT</span>
                </div>
                <div className="relative">
                    <input type="text" id="amount" value={inputValue} onChange={handleInputChange} className="w-full bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white p-3 rounded-md border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-primary" placeholder="0.00" aria-label={`Amount in ${inputType}`} />
                     <span className="absolute right-14 top-1/2 -translate-y-1/2 text-gray-500 dark:text-gray-400 font-semibold">{inputType.toUpperCase()}</span>
                     <button type="button" onClick={handleMaxClick} className="absolute right-2 top-1/2 -translate-y-1/2 bg-primary text-white text-xs px-2 py-1 rounded hover:bg-blue-500 transition-colors">MAX</button>
                </div>
                {subtext && <p className="text-right text-sm text-gray-500 dark:text-gray-400 mt-1 h-5">{subtext}</p>}
              </div>
              <div className="space-y-2 text-sm mb-4">
                    <div className="flex justify-between items-center text-gray-600 dark:text-gray-300">
                        <span>Subtotal</span>
                        <span className="font-mono text-gray-800 dark:text-gray-200">${usdtTotal.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</span>
                    </div>
                    <div className="flex justify-between items-center text-gray-600 dark:text-gray-300 relative group">
                        <span className="flex items-center cursor-help">Fee (0.1%)<i className="fas fa-info-circle text-xs ml-1.5 text-gray-400"></i></span>
                        <span className="font-mono text-gray-800 dark:text-gray-200">+${fee.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 4})}</span>
                        <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 w-max px-2 py-1 bg-gray-700 dark:bg-gray-900 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">A 0.1% fee is applied to simulate real trading conditions.<div className="absolute top-full left-1/2 -translate-x-1/2 w-0 h-0 border-x-4 border-x-transparent border-t-4 border-t-gray-700 dark:border-t-gray-900"></div></div>
                    </div>
              </div>
              <div className="border-t border-gray-200 dark:border-gray-600 my-4"></div>
              <div className="flex justify-between items-center text-xl font-bold mb-6">
                <span className="text-gray-600 dark:text-gray-300">Total</span>
                <span className="font-mono">${finalTotal.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</span>
              </div>
              <button type="submit" className="w-full p-3 rounded-md font-bold text-white transition-colors bg-success hover:bg-green-500">
                {orderType === 'market' ? 'Confirm Market Buy' : 'Place Limit Buy Order'}
              </button>
            </>)}
        </form>
      </div>
    </div>
  );
};

const PortfolioChart = ({ transactions, initialBalance }) => {
    const canvasRef = React.useRef(null);
    const chartInstanceRef = React.useRef(null);
    const { theme } = useTheme();

    const [chartData, setChartData] = React.useState(null);
    const [loading, setLoading] = React.useState(true);
    const [error, setError] = React.useState(null);
    const [timeRange, setTimeRange] = React.useState('90D');
    
    const sortedTxs = React.useMemo(() => {
        return [...transactions].sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    }, [transactions]);

    React.useEffect(() => {
        const generateChartData = async () => {
            if (sortedTxs.length === 0) { setLoading(false); setChartData(null); return; }
            try {
                setLoading(true); setError(null);
                const coinIds = [...new Set(sortedTxs.map(tx => tx.coin.id))];
                const days = { '7D': 7, '30D': 30, '90D': 90, '1Y': 365, 'ALL': 'max' }[timeRange];
                const priceResults = [];
                for (const id of coinIds) {
                    try {
                        const result = await getCoinMarketChart(id, days);
                        priceResults.push(result);
                    } catch (e) {
                        console.error(`Could not fetch market data for ${id}, skipping for chart.`, e);
                        priceResults.push({ prices: [], total_volumes: [] });
                    }
                    await new Promise(resolve => setTimeout(resolve, 350));
                }
                const priceMap = {};
                coinIds.forEach((id, index) => {
                    priceMap[id] = {};
                    priceResults[index]?.prices.forEach(([timestamp, price]) => {
                        const dateStr = dateFns.format(new Date(timestamp), 'yyyy-MM-dd');
                        priceMap[id][dateStr] = price;
                    });
                });
                const endDate = new Date(); endDate.setUTCHours(0, 0, 0, 0);
                let startDate;
                if (days === 'max') { startDate = new Date(sortedTxs[0].date); } 
                else if (days === 365) { startDate = dateFns.subYears(endDate, 1); } 
                else { startDate = dateFns.subDays(endDate, days - 1); }
                startDate.setUTCHours(0, 0, 0, 0);
                const portfolioHistory = [];
                const transactionPoints = [];
                let currentHoldings = {};
                let currentUsdtBalance = initialBalance;
                const relevantTxsBeforeStart = sortedTxs.filter(tx => new Date(tx.date) < startDate);
                for (const tx of relevantTxsBeforeStart) {
                     if (tx.type === 'buy') {
                        currentUsdtBalance -= tx.total;
                        currentHoldings[tx.coin.id] = (currentHoldings[tx.coin.id] || 0) + tx.amount;
                    } else {
                        currentUsdtBalance += tx.total;
                        currentHoldings[tx.coin.id] = (currentHoldings[tx.coin.id] || 0) - tx.amount;
                    }
                }
                let txIndex = relevantTxsBeforeStart.length;
                for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                    const currentDate = new Date(d);
                    const currentDateStr = dateFns.format(currentDate, 'yyyy-MM-dd');
                    const nextDay = new Date(currentDate); nextDay.setDate(nextDay.getDate() + 1);
                    while (txIndex < sortedTxs.length && new Date(sortedTxs[txIndex].date) < nextDay) {
                        const tx = sortedTxs[txIndex];
                        if (tx.type === 'buy') {
                            currentUsdtBalance -= tx.total;
                            currentHoldings[tx.coin.id] = (currentHoldings[tx.coin.id] || 0) + tx.amount;
                        } else {
                            currentUsdtBalance += tx.total;
                            currentHoldings[tx.coin.id] = (currentHoldings[tx.coin.id] || 0) - tx.amount;
                        }
                        transactionPoints.push({ x: new Date(tx.date).getTime(), y: 0, type: tx.type });
                        txIndex++;
                    }
                    let holdingsValue = 0;
                    for (const coinId in currentHoldings) {
                        const amount = currentHoldings[coinId];
                        if (amount > 1e-9) {
                            let priceForDay = priceMap[coinId]?.[currentDateStr];
                            if (!priceForDay) {
                                for (let i = 1; i <= 7; i++) {
                                    const lookbackDate = dateFns.subDays(currentDate, i);
                                    const lookbackDateStr = dateFns.format(lookbackDate, 'yyyy-MM-dd');
                                    if (priceMap[coinId]?.[lookbackDateStr]) { priceForDay = priceMap[coinId][lookbackDateStr]; break; }
                                }
                            }
                            if (priceForDay) holdingsValue += amount * priceForDay;
                        }
                    }
                    const totalValue = holdingsValue + currentUsdtBalance;
                    portfolioHistory.push({ date: currentDate.getTime(), value: totalValue });
                }
                const valueMap = new Map(portfolioHistory.map(p => [dateFns.format(new Date(p.date), 'yyyy-MM-dd'), p.value]));
                transactionPoints.forEach(p => { p.y = valueMap.get(dateFns.format(new Date(p.x), 'yyyy-MM-dd')) || 0; });
                setChartData({ labels: portfolioHistory.map(p => p.date), datasets: [{ label: 'Portfolio Value', data: portfolioHistory.map(p => p.value), type: 'line', }, { label: 'Initial Investment', data: portfolioHistory.map(() => initialBalance), type: 'line', }, { label: 'Transactions', data: transactionPoints, type: 'scatter', }] });
            } catch (e) {
                console.error("Failed to generate portfolio chart data:", e);
                setError("Could not load chart data due to an external API error. Please try again later.");
            } finally { setLoading(false); }
        };
        generateChartData();
    }, [sortedTxs, initialBalance, timeRange]);

    React.useEffect(() => {
        if (!canvasRef.current || !chartData) {
            if (chartInstanceRef.current) chartInstanceRef.current.destroy();
            return;
        }
        if (chartInstanceRef.current) chartInstanceRef.current.destroy();
        const ctx = canvasRef.current.getContext('2d');
        if (!ctx) return;
        const isDark = theme === 'dark';
        const gridColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.05)';
        const textColor = isDark ? '#e5e7eb' : '#4b5563';
        const primaryColor = '#3b82f6';
        const successColor = '#22c55e';
        const dangerColor = '#ef4444';
        const gradient = ctx.createLinearGradient(0, 0, 0, 300);
        gradient.addColorStop(0, 'rgba(59, 130, 246, 0.3)');
        gradient.addColorStop(1, isDark ? 'rgba(59, 130, 246, 0.01)' : 'rgba(59, 130, 246, 0)');
        chartInstanceRef.current = new Chart(ctx, {
            data: { labels: chartData.labels, datasets: [ { ...chartData.datasets[0], fill: true, borderColor: primaryColor, backgroundColor: gradient, pointRadius: 0, tension: 0.3, borderWidth: 2, }, { ...chartData.datasets[1], borderColor: isDark ? '#6b7280' : '#9ca3af', borderDash: [5, 5], pointRadius: 0, borderWidth: 1, }, { ...chartData.datasets[2], pointBackgroundColor: (context) => context.raw.type === 'buy' ? successColor : dangerColor, pointBorderColor: (context) => context.raw.type === 'buy' ? successColor : dangerColor, pointRadius: 5, pointHoverRadius: 8, } ] },
            options: { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'time', time: { unit: 'day', tooltipFormat: 'MMM d, yyyy' }, ticks: { color: textColor, maxRotation: 0, autoSkip: true, autoSkipPadding: 20 }, grid: { display: false }, }, y: { ticks: { color: textColor, callback: (value) => `$${Number(value).toLocaleString()}`, }, grid: { color: gridColor }, border: { display: false } } }, plugins: { legend: { display: false }, tooltip: { mode: 'index', intersect: false, backgroundColor: isDark ? '#1e1e1e' : '#fff', titleColor: textColor, bodyColor: textColor, borderColor: gridColor, borderWidth: 1, callbacks: { label: (context) => { if (context.dataset.label === 'Portfolio Value') { return ` Value: $${context.parsed.y.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`; } return null; }, }, }, }, interaction: { mode: 'index', intersect: false, }, }
        });
        return () => { if (chartInstanceRef.current) chartInstanceRef.current.destroy(); };
    }, [chartData, theme, initialBalance]);

    const TimeRangeButton = ({ range }) => (
        <button onClick={() => setTimeRange(range)} className={`px-3 py-1 text-sm font-semibold rounded-md transition-colors ${timeRange === range ? 'bg-primary text-white' : 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600'}`} >{range}</button>
    );

    return (
        <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg shadow-lg">
            <div className="flex flex-col sm:flex-row justify-between sm:items-center mb-4 gap-3">
                <h2 className="text-xl font-semibold text-gray-900 dark:text-white">Portfolio History</h2>
                <div className="flex items-center space-x-2 p-1 bg-gray-200 dark:bg-gray-900/50 rounded-lg">
                    {['7D', '30D', '90D', '1Y', 'ALL'].map(r => <TimeRangeButton key={r} range={r} />)}
                </div>
            </div>
            <div className="relative h-72">
                {loading && ( <div className="absolute inset-0 flex items-center justify-center bg-gray-100/50 dark:bg-gray-800/50 z-10"><i className="fas fa-spinner fa-spin text-2xl text-primary"></i><p className="ml-3 text-gray-500 dark:text-gray-400">Building portfolio history chart...</p></div> )}
                {error && <div className="absolute inset-0 flex items-center justify-center text-danger text-center p-4">{error}</div>}
                {!loading && !error && (transactions.length === 0 || !chartData) && ( <div className="absolute inset-0 flex items-center justify-center text-center"><div className="text-gray-500 dark:text-gray-500"><i className="fas fa-chart-line text-4xl mb-3"></i><p>Your portfolio chart will appear here once you make your first transaction.</p></div></div> )}
                <canvas ref={canvasRef}></canvas>
            </div>
        </div>
    );
};

const Portfolio = ({ setActivePage }) => {
    const { portfolio, cancelLimitOrder } = usePortfolio();
    const { coins, loading: coinsLoading } = useDApp();
    const [isTradeModalOpen, setTradeModalOpen] = React.useState(false);
    const [isBuyModalOpen, setBuyModalOpen] = React.useState(false);
    const [selectedCoin, setSelectedCoin] = React.useState(null);
    const [tradeType, setTradeType] = React.useState('buy');
    const handleTradeClick = (coin, type) => { setSelectedCoin(coin); setTradeType(type); setTradeModalOpen(true); };
    const handleBuyNewAsset = () => { setBuyModalOpen(true); };
    const portfolioData = React.useMemo(() => {
        if (coinsLoading) return { holdings: [], portfolioValue: portfolio.usdtBalance, totalPNL: 0, pnlPercentage: 0 };
        const holdingsArray = Object.values(portfolio.holdings);
        let totalHoldingsValue = 0;
        const detailedHoldings = holdingsArray.map(holding => {
            const currentCoinData = coins.find(c => c.id === holding.coin.id);
            const currentPrice = currentCoinData ? currentCoinData.current_price : holding.avgBuyPrice;
            const currentValue = holding.amount * currentPrice;
            const boughtValue = holding.amount * holding.avgBuyPrice;
            const pnl = currentValue - boughtValue;
            const pnlPercentage = boughtValue > 0 ? (pnl / boughtValue) * 100 : 0;
            totalHoldingsValue += currentValue;
            return { ...holding, currentValue, pnl, boughtValue, pnlPercentage };
        });
        const portfolioValue = portfolio.usdtBalance + totalHoldingsValue;
        const totalPNL = portfolioValue - portfolio.initialBalance;
        const pnlPercentage = portfolio.initialBalance > 0 ? (totalPNL / portfolio.initialBalance) * 100 : 0;
        return { holdings: detailedHoldings, portfolioValue, totalPNL, pnlPercentage };
    }, [portfolio, coins, coinsLoading]);
    if (coinsLoading && !portfolioData.holdings.length) { return <div className="text-center p-10"><i className="fas fa-spinner fa-spin text-4xl text-primary"></i><p className="mt-4">Loading portfolio data...</p></div>; }
    const PortfolioHeader = ({ portfolioValue, totalPNL, pnlPercentage }) => (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg text-center"><h3 className="text-gray-500 dark:text-gray-400 text-sm font-medium">Total Portfolio Value</h3><p className="text-2xl font-bold">${portfolioValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p></div>
            <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg text-center"><h3 className="text-gray-500 dark:text-gray-400 text-sm font-medium">Total Profit/Loss</h3><p className={`text-2xl font-bold ${totalPNL >= 0 ? 'text-success' : 'text-danger'}`}>{totalPNL >= 0 ? '+' : '-'}${Math.abs(totalPNL).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p></div>
            <div className="relative group cursor-help"><div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg text-center"><h3 className="text-gray-500 dark:text-gray-400 text-sm font-medium">P/L Percentage</h3><p className={`text-2xl font-bold ${pnlPercentage >= 0 ? 'text-success' : 'text-danger'}`}>{pnlPercentage.toFixed(2)}%</p></div><div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 w-max px-3 py-1.5 bg-gray-700 dark:bg-gray-900 text-white text-sm rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">Total P/L: {totalPNL >= 0 ? '+' : '-'}${Math.abs(totalPNL).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}<div className="absolute top-full left-1/2 -translate-x-1/2 w-0 h-0 border-x-4 border-x-transparent border-t-4 border-t-gray-700 dark:border-t-gray-900"></div></div></div>
        </div>
    );
    const HoldingsTable = ({ holdings, onTrade, onBuyNewAsset }) => (
        <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg overflow-x-auto"><h2 className="text-xl font-semibold mb-4">My Holdings</h2><table className="w-full text-left"><thead><tr className="border-b border-gray-200 dark:border-gray-700 text-gray-500 dark:text-gray-400"><th className="p-2">Asset</th><th className="p-2 text-right">Amount</th><th className="p-2 text-right">Avg. Buy Price</th><th className="p-2 text-right">Bought Value</th><th className="p-2 text-right">Current Value</th><th className="p-2 text-right">P/L</th><th className="p-2 text-center">Actions</th></tr></thead>
            <tbody>{holdings.length > 0 ? holdings.map(({ coin, amount, avgBuyPrice, boughtValue, currentValue, pnl, pnlPercentage }) => (
                    <tr key={coin.id} className="border-b border-gray-200 dark:border-gray-700 last:border-b-0 hover:bg-gray-200 dark:hover:bg-gray-700">
                        <td className="p-2 flex items-center"><img src={coin.image} alt={coin.name} className="w-6 h-6 mr-2" />{coin.name} <span className="text-gray-500 dark:text-gray-400 ml-1">{coin.symbol.toUpperCase()}</span></td>
                        <td className="p-2 text-right">{amount.toFixed(6)}</td><td className="p-2 text-right">${avgBuyPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 4 })}</td><td className="p-2 text-right">${boughtValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td><td className="p-2 text-right">${currentValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                        <td className={`p-2 text-right font-semibold ${pnl >= 0 ? 'text-success' : 'text-danger'}`}><div>{pnl >= 0 ? '+' : '-'}${Math.abs(pnl).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div><div className="text-xs font-normal">({pnlPercentage > 0 ? '+' : ''}{pnlPercentage.toFixed(2)}%)</div></td>
                        <td className="p-2 text-center space-x-2"><button onClick={() => onTrade(coin, 'buy')} className="bg-success text-white px-3 py-1 rounded-md text-sm hover:bg-green-500">Buy</button><button onClick={() => onTrade(coin, 'sell')} className="bg-danger text-white px-3 py-1 rounded-md text-sm hover:bg-red-500">Sell</button></td>
                    </tr>)) : (<tr><td colSpan={7} className="text-center p-8"><p className="text-gray-500 dark:text-gray-500 mb-4">Your portfolio is empty. Make your first trade to get started!</p><button onClick={onBuyNewAsset} className="bg-primary text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-500 transition-colors"><i className="fas fa-plus mr-2"></i>Buy New Asset</button></td></tr>)}</tbody></table></div>
    );
    const LimitOrdersSection = ({ orders, onCancel }) => {
        const [activeTab, setActiveTab] = React.useState('open'); // 'open' or 'history'
        const openOrders = React.useMemo(() => orders.filter(o => o.status === 'open'), [orders]);
        const historyOrders = React.useMemo(() => orders.filter(o => o.status === 'filled' || o.status === 'cancelled').sort((a,b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()), [orders]);
        const ordersToDisplay = activeTab === 'open' ? openOrders : historyOrders;
        const StatusBadge = ({ status }) => {
            const styles = {
                open: 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300 capitalize',
                filled: 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300 capitalize',
                cancelled: 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300 capitalize',
            };
            return <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${styles[status]}`}>{status}</span>;
        };
        const TabButton = ({ tab, label, count }) => (
            <button onClick={() => setActiveTab(tab)} className={`px-4 py-2 text-sm font-medium rounded-md transition-colors ${activeTab === tab ? 'bg-primary text-white' : 'text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700'}`}>
                {label} <span className="ml-1 px-2 py-0.5 bg-gray-300 dark:bg-gray-600 rounded-full text-xs">{count}</span>
            </button>
        );
        return (
            <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg overflow-x-auto mt-6">
                <div className="flex flex-col sm:flex-row justify-between sm:items-center mb-4 gap-3">
                    <h2 className="text-xl font-semibold">Limit Orders</h2>
                    <div className="flex space-x-2 p-1 bg-gray-200 dark:bg-gray-900/50 rounded-lg">
                        <TabButton tab="open" label="Open" count={openOrders.length} />
                        <TabButton tab="history" label="History" count={historyOrders.length} />
                    </div>
                </div>
                {ordersToDisplay.length > 0 ? (
                    <table className="w-full text-left">
                        <thead>
                            <tr className="border-b border-gray-200 dark:border-gray-700 text-gray-500 dark:text-gray-400">
                                <th className="p-2">Asset</th>
                                <th className="p-2">Type</th>
                                <th className="p-2 text-right">Amount</th>
                                <th className="p-2 text-right">Limit Price</th>
                                <th className="p-2 text-center">Status</th>
                                <th className="p-2">Date</th>
                                <th className="p-2 text-center">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {ordersToDisplay.map(order => (
                                <tr key={order.id} className="border-b border-gray-200 dark:border-gray-700 last:border-b-0 hover:bg-gray-200 dark:hover:bg-gray-700 text-sm">
                                    <td className="p-2 flex items-center"><img src={order.coin.image} alt={order.coin.name} className="w-6 h-6 mr-2" />{order.coin.name}</td>
                                    <td className={`p-2 font-semibold capitalize ${order.type === 'buy' ? 'text-success' : 'text-danger'}`}>{order.type}</td>
                                    <td className="p-2 text-right">{order.amount.toFixed(6)}</td>
                                    <td className="p-2 text-right">${order.limitPrice.toLocaleString()}</td>
                                    <td className="p-2 text-center"><StatusBadge status={order.status} /></td>
                                    <td className="p-2 text-gray-500 dark:text-gray-400">{new Date(order.createdAt).toLocaleString()}</td>
                                    <td className="p-2 text-center" style={{width: '80px'}}>
                                        {order.status === 'open' && (
                                            <button onClick={() => onCancel(order.id)} className="bg-gray-500 text-white px-3 py-1 rounded-md text-xs hover:bg-gray-600">Cancel</button>
                                        )}
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                ) : (
                    <div className="text-center p-6 text-gray-500 dark:text-gray-500">
                        {activeTab === 'open' ? 'You have no open limit orders.' : 'You have no limit order history.'}
                    </div>
                )}
            </div>
        );
    };
    const AIInsight = () => { const { portfolio } = usePortfolio(); const [insight, setInsight] = React.useState(null); const [loading, setLoading] = React.useState(false); const handleGetInsight = async () => { setLoading(true); setInsight(null); const result = await getPortfolioAnalysis(portfolio); setInsight(result); setLoading(false); }; const InsightItem = ({ icon, title, content, colorClass }) => (<div className="flex items-start space-x-4"><div className={`flex-shrink-0 w-10 h-10 rounded-lg flex items-center justify-center ${colorClass}`}><i className={`fas ${icon} text-white text-xl`}></i></div><div><h4 className="font-semibold text-gray-800 dark:text-gray-200">{title}</h4><p className="text-gray-600 dark:text-gray-400 text-sm">{content}</p></div></div>); return (
        <div className="bg-gray-100 dark:bg-gray-800 p-6 rounded-lg mt-6"><div className="flex justify-between items-center mb-4"><h2 className="text-xl font-semibold text-primary"><i className="fas fa-brain mr-2"></i>AI Portfolio Insight</h2><button onClick={handleGetInsight} disabled={loading} className="bg-primary text-white px-4 py-2 rounded-md hover:bg-blue-500 disabled:bg-gray-600 flex items-center"><i className={`fas fa-sync mr-2 ${loading ? 'animate-spin' : ''}`}></i>{loading ? 'Analyzing...' : 'Get Insight'}</button></div>{loading && (<div className="text-center p-4"><i className="fas fa-spinner fa-spin text-2xl text-primary"></i><p className="mt-2 text-gray-500 dark:text-gray-400">The AI is analyzing your portfolio...</p></div>)}{insight && (<div className="space-y-6"><div className="bg-gray-200 dark:bg-gray-700/50 p-4 rounded-lg"><h3 className="font-semibold text-lg mb-2 text-gray-900 dark:text-white">Overall Assessment</h3><p className="text-gray-700 dark:text-gray-300 italic">"{insight.overallAssessment}"</p></div><div className="grid grid-cols-1 md:grid-cols-2 gap-6"><InsightItem icon="fa-shield-alt" title={`Risk Analysis (Score: ${insight.riskScore}/10)`} content={insight.riskAnalysis} colorClass="bg-danger/80" /><InsightItem icon="fa-cubes" title="Diversification Suggestion" content={insight.diversification} colorClass="bg-secondary/80" /><InsightItem icon="fa-balance-scale" title="Rebalancing Opportunities" content={insight.rebalancingOpportunities} colorClass="bg-yellow-500/80" /><InsightItem icon="fa-check-circle" title="Positive Note" content={insight.positiveNote} colorClass="bg-success/80" /></div></div>)}{!loading && !insight && (<div className="text-center text-gray-500 dark:text-gray-500 p-4"><p>Click "Get Insight" for a detailed AI-powered analysis of your portfolio.</p></div>)}</div>
    );};
    const TransactionHistoryTable = ({ transactions }) => { const [sortConfig, setSortConfig] = React.useState({ key: 'date', direction: 'desc' }); const sortedTransactions = React.useMemo(() => { const sortableItems = [...transactions]; if (sortConfig.key) { sortableItems.sort((a, b) => { let comparison = 0; if (sortConfig.key === 'date') { comparison = new Date(a.date).getTime() - new Date(b.date).getTime(); } else if (sortConfig.key === 'pnl') { const isASell = a.type === 'sell'; const isBSell = b.type === 'sell'; if (isASell && !isBSell) return -1; if (!isASell && isBSell) return 1; if (!isASell && !isBSell) return 0; comparison = (a.pnl ?? 0) - (b.pnl ?? 0); } else { comparison = a.type.localeCompare(b.type); } return sortConfig.direction === 'asc' ? comparison : -comparison; }); } return sortableItems; }, [transactions, sortConfig]); const handleSort = (key) => { setSortConfig(prevConfig => ({ key, direction: prevConfig.key === key && prevConfig.direction === 'asc' ? 'desc' : 'asc', })); }; const getSortIcon = (key) => { if (sortConfig.key !== key) { return <i className="fas fa-sort text-gray-400/50 ml-2"></i>; } return sortConfig.direction === 'asc' ? <i className="fas fa-sort-up text-primary ml-2"></i> : <i className="fas fa-sort-down text-primary ml-2"></i>; }; const totalRealizedPnl = React.useMemo(() => { return transactions.reduce((acc, tx) => acc + (tx.pnl ?? 0), 0); }, [transactions]); const SortableHeader = ({ sortKey, children }) => ( <th className="p-2"><button onClick={() => handleSort(sortKey)} className="flex items-center hover:text-gray-900 dark:hover:text-gray-100 transition-colors">{children}{getSortIcon(sortKey)}</button></th> ); return (
        <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg mt-6 overflow-x-auto"><h2 className="text-xl font-semibold mb-4">Transaction History</h2>{transactions.length > 0 ? (<table className="w-full text-left"><thead><tr className="border-b border-gray-200 dark:border-gray-700 text-gray-500 dark:text-gray-400 text-sm"><SortableHeader sortKey="type">Type</SortableHeader><th className="p-2">Asset</th><th className="p-2">Price</th><th className="p-2">Amount</th><th className="p-2">Fee</th><th className="p-2">Net Value</th><SortableHeader sortKey="pnl">P/L</SortableHeader><SortableHeader sortKey="date">Date</SortableHeader></tr></thead><tbody>{sortedTransactions.map((tx) => { const isBuy = tx.type === 'buy'; const pnl = tx.pnl ?? 0; const isPnlPositive = pnl >= 0; return (
            <tr key={tx.id} className="border-b border-gray-200 dark:border-gray-700 last:border-b-0 hover:bg-gray-200 dark:hover:bg-gray-700 text-sm"><td className="p-2"><span className={`font-bold ${isBuy ? 'text-success' : 'text-danger'}`}>{tx.type.toUpperCase()}</span></td><td className="p-2 flex items-center"><img src={tx.coin.image} alt={tx.coin.name} className="w-5 h-5 mr-2" />{tx.coin.name}</td><td className="p-2">${tx.price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td><td className="p-2">{tx.amount.toFixed(6)} {tx.coin.symbol.toUpperCase()}</td><td className="p-2">${(tx.fee ?? 0).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 4 })}</td><td className="p-2">${tx.total.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>{isBuy ? (<td className="p-2 text-center text-gray-500">-</td>) : (<td className={`p-2 font-semibold ${isPnlPositive ? 'text-success' : 'text-danger'}`}>${pnl.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>)}<td className="p-2 text-gray-500 dark:text-gray-400">{new Date(tx.date).toLocaleString()}</td></tr>);})}</tbody><tfoot><tr className="border-t-2 border-gray-300 dark:border-gray-600 font-bold"><td colSpan={6} className="p-2 text-right text-base">Total Realized P/L</td><td colSpan={2} className={`p-2 text-base ${totalRealizedPnl >= 0 ? 'text-success' : 'text-danger'}`}>${totalRealizedPnl.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td></tr></tfoot></table>) : (<div className="text-center p-8"><p className="text-gray-500">You have no transaction history yet.</p></div>)}</div>
    );};
    return (
        <div className="space-y-6"><h1 className="text-3xl font-bold text-gray-900 dark:text-white">My Portfolio</h1><PortfolioHeader {...portfolioData} /><PortfolioChart transactions={portfolio.transactions} initialBalance={portfolio.initialBalance} /><div className="flex flex-col sm:flex-row justify-between sm:items-center gap-4"><h2 className="text-2xl font-semibold">Assets</h2><div className="flex items-center gap-4"><div className="flex items-center bg-gray-100 dark:bg-gray-800 p-2 rounded-lg"><span className="text-gray-500 dark:text-gray-400 mr-2">Cash Balance:</span><span className="font-bold text-lg">${portfolio.usdtBalance.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span></div><button onClick={handleBuyNewAsset} className="bg-primary text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-500 transition-colors flex items-center justify-center"><i className="fas fa-plus mr-2"></i>Buy New Asset</button></div></div><HoldingsTable holdings={portfolioData.holdings} onTrade={handleTradeClick} onBuyNewAsset={handleBuyNewAsset} /><LimitOrdersSection orders={portfolio.limitOrders} onCancel={cancelLimitOrder} /><AIInsight /><TransactionHistoryTable transactions={portfolio.transactions} />{isTradeModalOpen && selectedCoin && (<TradeModal coin={selectedCoin} tradeType={tradeType} onClose={() => setTradeModalOpen(false)} />)}{isBuyModalOpen && (<BuyAssetModal onClose={() => setBuyModalOpen(false)} />)}</div>
    );
};

const Recommendations = () => {
    const { coins } = useDApp();
    const [recommendations, setRecommendations] = React.useState([]);
    const [loading, setLoading] = React.useState(true);
    const [error, setError] = React.useState(null);
    const hasFetchedOnMount = React.useRef(false);
    const fetchRecommendations = React.useCallback(async (isManualRefresh = false) => {
        if (coins.length === 0) { if (!isManualRefresh) return; setError("Market data is still loading. Please wait a moment and try again."); return; }
        setLoading(true); setError(null);
        try { const fearAndGreed = await getFearAndGreedIndex(); const result = await getAIRecommendations(coins, fearAndGreed.value); setRecommendations(result);
        } catch (err) { console.error("Failed to fetch recommendations:", err); setError("Could not generate AI recommendations. Displaying cached data. Please try again later."); const result = await getAIRecommendations(coins, 50); setRecommendations(result);
        } finally { setLoading(false); }
    }, [coins]);
    React.useEffect(() => { if (coins.length > 0 && !hasFetchedOnMount.current) { fetchRecommendations(false); hasFetchedOnMount.current = true; } }, [coins, fetchRecommendations]);
    const ScoreBreakdownDisplay = ({ breakdown }) => (
        <div className="w-full mt-4 p-4 bg-gray-100 dark:bg-gray-700 rounded-lg"><h4 className="text-sm font-semibold mb-3 text-gray-700 dark:text-gray-300">Score Breakdown</h4><ul className="text-sm space-y-2 text-gray-600 dark:text-gray-400"><li className="flex justify-between items-center"><span><i className="fas fa-chart-line mr-2 text-blue-400"></i>Market Trend (35%)</span><strong className="font-mono text-gray-800 dark:text-gray-200">{breakdown.trend}/35</strong></li><li className="flex justify-between items-center"><span><i className="fas fa-comments mr-2 text-purple-400"></i>Sentiment (20%)</span><strong className="font-mono text-gray-800 dark:text-gray-200">{breakdown.sentiment}/20</strong></li><li className="flex justify-between items-center"><span><i className="fas fa-microchip mr-2 text-green-400"></i>Fundamentals (20%)</span><strong className="font-mono text-gray-800 dark:text-gray-200">{breakdown.fundamentals}/20</strong></li><li className="flex justify-between items-center"><span><i className="fas fa-laptop-code mr-2 text-indigo-400"></i>Technology &amp; Innovation (15%)</span><strong className="font-mono text-gray-800 dark:text-gray-200">{breakdown.technology}/15</strong></li><li className="flex justify-between items-center"><span><i className="fas fa-tachometer-alt mr-2 text-yellow-400"></i>Market Mood (10%)</span><strong className="font-mono text-gray-800 dark:text-gray-200">{breakdown.mood}/10</strong></li></ul></div>
    );
    const RecommendationCard = ({ recommendation }) => {
        const { coins } = useDApp(); const coinData = coins.find(c => c.id === recommendation.coinId);
        const getScoreColor = (score) => { if (score > 75) return 'text-success'; if (score > 50) return 'text-yellow-400'; return 'text-danger'; };
        const getRecommendationColor = (rec) => { if (rec.includes('Buy')) return 'bg-success'; if (rec.includes('Hold')) return 'bg-yellow-500'; return 'bg-danger'; }
        return (<div className="bg-gray-100 dark:bg-gray-800 p-6 rounded-lg shadow-lg"><div className="flex flex-col md:flex-row items-center space-y-4 md:space-y-0 md:space-x-6">{coinData && <img src={coinData.image} alt={coinData.name} className="w-16 h-16"/>}<div className="flex-1 text-center md:text-left"><h3 className="text-2xl font-bold">{recommendation.coinName}</h3><p className="text-gray-600 dark:text-gray-400 mt-1">{recommendation.reasoning}</p></div><div className="flex items-center space-x-6"><div className="text-center"><p className="text-gray-500 dark:text-gray-400 text-sm">Score</p><p className={`text-5xl font-bold ${getScoreColor(recommendation.score)}`}>{recommendation.score}</p></div><div className={`${getRecommendationColor(recommendation.recommendation)} text-white font-bold py-2 px-4 rounded-md text-center`}>{recommendation.recommendation}</div></div></div>{recommendation.scoreBreakdown && <ScoreBreakdownDisplay breakdown={recommendation.scoreBreakdown} />}</div>);
    };
    return (
        <div className="space-y-6"><div className="flex justify-between items-center"><h1 className="text-3xl font-bold text-gray-900 dark:text-white">AI Recommendations</h1><button onClick={() => fetchRecommendations(true)} disabled={loading} className="bg-primary text-white px-4 py-2 rounded-md hover:bg-blue-500 disabled:bg-gray-600 flex items-center"><i className={`fas fa-sync mr-2 ${loading ? 'animate-spin' : ''}`}></i>{loading ? 'Refreshing...' : 'Refresh'}</button></div><p className="text-gray-600 dark:text-gray-400">These recommendations are generated by AI for the top 10 coins by market cap based on a weighted analysis of market data. This is not financial advice.</p>{error && <div className="bg-red-100 border border-danger text-red-700 dark:bg-red-900 dark:text-red-200 px-4 py-3 rounded-md">{error}</div>}{loading && recommendations.length === 0 ? (<div className="text-center p-10"><i className="fas fa-spinner fa-spin text-4xl text-primary"></i><p className="mt-4">{coins.length === 0 ? 'Loading market data...' : 'Analyzing market data and generating AI recommendations...'}</p></div>) : (<div className="space-y-4">{recommendations.map(rec => (<RecommendationCard key={rec.coinId} recommendation={rec} />))}</div>)}</div>
    );
};

const LearningCenter = () => {
    const AccordionItem = ({ title, icon, children }) => { const [isOpen, setIsOpen] = React.useState(false); return (
        <div className="bg-gray-100 dark:bg-gray-800 rounded-lg shadow-md mb-3 overflow-hidden"><button onClick={() => setIsOpen(!isOpen)} className="w-full flex justify-between items-center p-5 text-left font-semibold text-gray-800 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors" aria-expanded={isOpen}><span className="flex items-center"><i className={`fas ${icon} text-primary w-6 mr-4 text-xl`}></i><span className="text-lg">{title}</span></span><i className={`fas fa-chevron-down transform transition-transform duration-300 ${isOpen ? 'rotate-180' : ''}`}></i></button><div className={`transition-all duration-500 ease-in-out ${isOpen ? 'max-h-screen' : 'max-h-0'}`} style={{ transitionProperty: 'max-height, padding' }}><div className={`p-5 pt-0 text-gray-600 dark:text-gray-300 space-y-3 leading-relaxed ${isOpen ? 'opacity-100' : 'opacity-0'}`}>{children}</div></div></div>
    );};
    return (
        <div className="space-y-6"><h1 className="text-3xl font-bold text-gray-900 dark:text-white">Learning Center</h1><p className="text-gray-600 dark:text-gray-400">Expand your knowledge with these key topics in cryptocurrency investing.</p><div><AccordionItem title="Crypto Basics" icon="fa-cubes"><p><strong>Cryptocurrency:</strong> A digital or virtual currency that uses cryptography for security. Unlike traditional currencies issued by governments (fiat currencies), cryptocurrencies are typically decentralized.</p><p><strong>Blockchain:</strong> A distributed database that is shared among the nodes of a computer network. It's the technology that enables the existence of cryptocurrency by maintaining a secure and decentralized record of transactions.</p><p><strong>Wallet:</strong> A digital wallet used to store, send, and receive cryptocurrencies. Wallets can be software-based (desktop, mobile, web) or hardware-based (physical devices).</p></AccordionItem><AccordionItem title="Understanding Order Types" icon="fa-exchange-alt"><p><strong>Market Order:</strong> This is the simplest type of trade. It's an order to buy or sell an asset immediately at the best available current price. It guarantees execution but not the price.</p><p><strong>Limit Order:</strong> An order to buy or sell an asset at a specific price or better. A buy limit order will only execute at the limit price or lower, and a sell limit order will only execute at the limit price or higher. This gives you control over the price but does not guarantee the order will be filled.</p></AccordionItem><AccordionItem title="Common Trading Strategies" icon="fa-chart-line"><p><strong>HODL (Hold On for Dear Life):</strong> A long-term strategy where investors buy a cryptocurrency and hold it for a long period, regardless of market fluctuations, with the belief that the price will increase over time.</p><p><strong>Dollar-Cost Averaging (DCA):</strong> An investment strategy where you invest a fixed amount of money at regular intervals, regardless of the asset's price. This can help reduce the impact of volatility.</p></AccordionItem><AccordionItem title="Risks of Investing" icon="fa-exclamation-triangle"><p><strong>Volatility:</strong> Cryptocurrency prices can be extremely volatile, with large price swings in short periods. You could lose a significant portion of your investment quickly.</p><p><strong>Regulatory Risk:</strong> The legal and regulatory landscape for cryptocurrencies is still evolving. New regulations could impact the value and legality of certain assets.</p><p><strong>Security Risk:</strong> Exchanges can be hacked, and assets can be stolen. It's crucial to use strong security practices, such as two-factor authentication and secure wallets.</p></AccordionItem></div><div className="bg-red-50 dark:bg-red-900/50 border-l-4 border-danger text-red-800 dark:text-red-100 p-4 rounded-r-lg" role="alert"><p className="font-bold"><i className="fas fa-gavel mr-2"></i>Disclaimer</p><p>This application is for educational and entertainment purposes only. The information provided, including AI-generated content, does not constitute financial advice. Always do your own research (DYOR) and consult with a qualified financial advisor before making any investment decisions.</p></div></div>
    );
};

const TradingViewWidget = React.memo(({ coinSymbol }) => {
  const containerRef = React.useRef(null);
  const { theme } = useTheme();
  const containerId = 'tradingview_widget_container';
  React.useEffect(() => {
    if (!containerRef.current || typeof TradingView === 'undefined' || !coinSymbol) return;
    containerRef.current.innerHTML = '';
    new TradingView.widget({ autosize: true, symbol: `${coinSymbol.toUpperCase()}USD`, interval: 'D', timezone: 'Etc/UTC', theme: theme, style: '1', locale: 'en', enable_publishing: false, withdateranges: true, hide_side_toolbar: false, allow_symbol_change: true, studies: ["MovingAverage@tv-basicstudies", "MAExp@tv-basicstudies", "RSI@tv-basicstudies", "MACD@tv-basicstudies"], container_id: containerId, backgroundColor: theme === 'dark' ? '#1e1e1e' : '#f9fafb', gridColor: theme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.06)', });
  }, [coinSymbol, theme]);
  return <div id={containerId} ref={containerRef} className="relative" style={{ height: '450px' }} />;
});

const TrendPredictionCard = ({ prediction, loading, error }) => {
    if (loading) return <div className="text-center p-4"><i className="fas fa-spinner fa-spin text-primary text-xl"></i><p className="mt-2 text-sm text-gray-500 dark:text-gray-400">Analyzing trend...</p></div>;
    if (error || !prediction) return <div className="bg-red-50 dark:bg-red-900/20 border border-danger/50 text-danger p-4 rounded-lg flex items-center space-x-3"><i className="fas fa-exclamation-triangle text-xl"></i><div><h4 className="font-semibold">Prediction Failed</h4><p className="text-sm">{error || "Could not generate prediction data."}</p></div></div>;
    const TrendIcon = ({ trend }) => { if (trend === 'Bullish') return <i className="fas fa-arrow-trend-up text-success text-3xl"></i>; if (trend === 'Bearish') return <i className="fas fa-arrow-trend-down text-danger text-3xl"></i>; return <i className="fas fa-minus text-gray-500 dark:text-gray-400 text-3xl"></i>; };
    const ConfidenceBar = ({ confidence }) => { const getColor = (value) => { if (value > 75) return 'bg-success'; if (value > 50) return 'bg-yellow-400'; return 'bg-danger'; }; return <div><div className="flex justify-between items-center mb-1 text-sm"><span className="text-gray-500 dark:text-gray-400">Confidence</span><span className="font-semibold">{confidence}%</span></div><div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2.5"><div className={`${getColor(confidence)} h-2.5 rounded-full transition-all duration-500`} style={{ width: `${confidence}%` }}></div></div></div>; };
    return <div className="p-4 rounded-lg"><div className="flex items-center space-x-4 mb-4"><TrendIcon trend={prediction.trend} /><div><p className="text-2xl font-bold">Likely {prediction.trend}</p><p className="text-gray-500 dark:text-gray-400 text-sm">Short-term (7-day) forecast</p></div></div><ConfidenceBar confidence={prediction.confidence} /><p className="text-gray-600 dark:text-gray-300 mt-4 text-sm italic bg-gray-200 dark:bg-gray-700/50 p-3 rounded-md"><i className="fas fa-quote-left mr-2 opacity-50"></i>{prediction.analysis}</p></div>;
};

const FundamentalsCard = ({ data, loading, error }) => {
    if (loading) return <div className="text-center p-4"><i className="fas fa-spinner fa-spin text-primary text-xl"></i><p className="mt-2 text-sm text-gray-500 dark:text-gray-400">Loading fundamentals...</p></div>;
    if (error || !data) return <div className="bg-red-50 dark:bg-red-900/20 border border-danger/50 text-danger p-4 rounded-lg flex items-center space-x-3"><i className="fas fa-exclamation-triangle text-xl"></i><div><h4 className="font-semibold">Analysis Failed</h4><p className="text-sm">{error || 'Could not load fundamental data.'}</p></div></div>;
    const AccordionItem = ({ title, children, icon }) => { const [isOpen, setIsOpen] = React.useState(false); return <div className="border-b border-gray-200 dark:border-gray-700 last:border-b-0"><h2><button type="button" className="flex justify-between items-center w-full p-4 font-medium text-left text-gray-800 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700" onClick={() => setIsOpen(!isOpen)} aria-expanded={isOpen}><div className="flex items-center"><i className={`fas ${icon} w-5 mr-3 text-primary`}></i><span>{title}</span></div><i className={`fas fa-chevron-down w-3 h-3 transform transition-transform ${isOpen ? 'rotate-180' : ''}`}></i></button></h2><div className={`transition-all duration-300 ease-in-out ${isOpen ? 'max-h-screen' : 'max-h-0 overflow-hidden'}`}><div className="p-4 pt-0 text-gray-600 dark:text-gray-400 text-sm leading-relaxed"><p>{children}</p></div></div></div>; };
    return <div className="border border-gray-200 dark:border-gray-700 rounded-lg"><AccordionItem title="Project Background" icon="fa-info-circle">{data.background}</AccordionItem><AccordionItem title="Tokenomics" icon="fa-coins">{data.tokenomics}</AccordionItem><AccordionItem title="Team & Development" icon="fa-users">{data.team}</AccordionItem></div>;
};

const CreateAlertModal = ({ onClose, defaultCoinId }) => {
  const { coins } = useDApp(); const { addAlert } = useAlerts();
  const [coinId, setCoinId] = React.useState(defaultCoinId || '');
  const [condition, setCondition] = React.useState('above');
  const [targetPrice, setTargetPrice] = React.useState('');
  const selectedCoin = React.useMemo(() => coins.find(c => c.id === coinId), [coinId, coins]);
  const handleSubmit = (e) => {
    e.preventDefault(); const price = parseFloat(targetPrice);
    if (!coinId || isNaN(price) || price <= 0) { alert("Please fill out all fields with valid values."); return; }
    addAlert({ coinId, condition, targetPrice: price }); onClose();
  };
  return <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"><div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md m-4"><div className="flex justify-between items-center mb-6"><h2 className="text-2xl font-bold">Create Price Alert</h2><button onClick={onClose} className="text-gray-500 dark:text-gray-400 hover:text-gray-800 dark:hover:text-white text-2xl leading-none">&times;</button></div><form onSubmit={handleSubmit} className="space-y-4"><div><label htmlFor="coin" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Cryptocurrency</label><select id="coin" value={coinId} onChange={(e) => setCoinId(e.target.value)} className="w-full bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white p-3 rounded-md border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-primary"><option value="" disabled>-- Select a coin --</option>{coins.map(coin => (<option key={coin.id} value={coin.id}>{coin.name} ({coin.symbol.toUpperCase()})</option>))}</select></div>{selectedCoin && (<div className="bg-gray-100 dark:bg-gray-700/50 p-2 rounded-md text-center text-sm">Current Price: <span className="font-semibold text-gray-900 dark:text-white">${selectedCoin.current_price.toLocaleString()}</span></div>)}<div><label className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Condition</label><div className="grid grid-cols-2 gap-2"><button type="button" onClick={() => setCondition('above')} className={`p-3 rounded-md text-center transition-colors ${condition === 'above' ? 'bg-primary text-white' : 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600'}`}><i className="fas fa-arrow-up mr-2"></i>Price is Above</button><button type="button" onClick={() => setCondition('below')} className={`p-3 rounded-md text-center transition-colors ${condition === 'below' ? 'bg-primary text-white' : 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600'}`}><i className="fas fa-arrow-down mr-2"></i>Price is Below</button></div></div><div><label htmlFor="targetPrice" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Target Price (USD)</label><div className="relative"><span className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-500 dark:text-gray-400">$</span><input type="text" id="targetPrice" value={targetPrice} onChange={(e) => /^\d*\.?\d*$/.test(e.target.value) && setTargetPrice(e.target.value)} className="w-full bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white p-3 pl-6 rounded-md border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-primary" placeholder="e.g., 70000" /></div></div><button type="submit" className="w-full p-3 rounded-md font-bold text-white transition-colors bg-success hover:bg-green-500 disabled:bg-gray-600" disabled={!coinId || !targetPrice}>Create Alert</button></form></div></div>;
};

const CoinResearch = ({ coin, setActivePage }) => {
    const { isFavorite, addFavorite, removeFavorite } = useFavorites();
    const [isAnimating, setIsAnimating] = React.useState(false);
    const [news, setNews] = React.useState([]); const [loadingNews, setLoadingNews] = React.useState(true); const [newsError, setNewsError] = React.useState(null);
    const [trendPrediction, setTrendPrediction] = React.useState(null); const [predictionLoading, setPredictionLoading] = React.useState(true); const [predictionError, setPredictionError] = React.useState(null);
    const [fundamentals, setFundamentals] = React.useState(null); const [loadingFundamentals, setLoadingFundamentals] = React.useState(true); const [fundamentalsError, setFundamentalsError] = React.useState(null);
    const [coinDetails, setCoinDetails] = React.useState(null); const [loadingDetails, setLoadingDetails] = React.useState(true); const [detailsError, setDetailsError] = React.useState(null);
    const [isAlertModalOpen, setAlertModalOpen] = React.useState(false);
    const isFav = isFavorite(coin.id);
    const handleFavoriteToggle = () => { if (isAnimating) return; if (!isFav) { setIsAnimating(true); setTimeout(() => setIsAnimating(false), 400); } if (isFav) removeFavorite(coin.id); else addFavorite(coin.id); };
    React.useEffect(() => {
        const fetchAllCoinData = async () => {
            setLoadingNews(true); setPredictionLoading(true); setLoadingFundamentals(true); setLoadingDetails(true);
            setNewsError(null); setPredictionError(null); setFundamentalsError(null); setDetailsError(null);
            getCoinNews(coin.symbol).then(setNews).catch(err => { setNewsError("Could not load news articles."); }).finally(() => setLoadingNews(false));
            getCoinMarketChart(coin.id).then(marketData => { if (marketData && marketData.prices.length > 0) return getTrendPrediction(coin.name, marketData.prices); throw new Error("No historical data available."); }).then(setTrendPrediction).catch(err => { setPredictionError(`Could not generate AI prediction.`); }).finally(() => setPredictionLoading(false));
            getFundamentalData(coin.symbol).then(setFundamentals).catch(err => { setFundamentalsError("Could not load fundamental data."); }).finally(() => setLoadingFundamentals(false));
            getCoinDetails(coin.id).then(setCoinDetails).catch(err => { setDetailsError("Could not load additional coin details."); }).finally(() => setLoadingDetails(false));
        };
        fetchAllCoinData();
    }, [coin]);
    const StatCard = ({ label, value }) => (<div className="bg-gray-200 dark:bg-gray-700/60 p-3 rounded-lg text-center"><h4 className="text-sm text-gray-500 dark:text-gray-400 font-medium">{label}</h4><p className="text-lg font-semibold">{value}</p></div>);
    const AccordionItem = ({ title, icon, children, defaultOpen = false }) => { const [isOpen, setIsOpen] = React.useState(defaultOpen); return <div className="bg-gray-100 dark:bg-gray-800 rounded-lg shadow-md mb-3 overflow-hidden"><button onClick={() => setIsOpen(!isOpen)} className="w-full flex justify-between items-center p-5 text-left font-semibold text-gray-800 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors" aria-expanded={isOpen}><span className="flex items-center"><i className={`fas ${icon} text-primary w-6 mr-4 text-xl`}></i><span className="text-lg">{title}</span></span><i className={`fas fa-chevron-down transform transition-transform duration-300 ${isOpen ? 'rotate-180' : ''}`}></i></button><div className={`transition-all duration-500 ease-in-out ${isOpen ? 'max-h-[2000px]' : 'max-h-0'}`} style={{ transitionProperty: 'max-height' }}><div className={`p-5 pt-0 text-gray-600 dark:text-gray-300 space-y-4 leading-relaxed`}>{children}</div></div></div> };
    const StatDisplay = ({ icon, label, value }) => (<div className="bg-gray-200 dark:bg-gray-700 p-3 rounded-lg"><div className="flex items-center text-sm text-gray-500 dark:text-gray-400 mb-1"><i className={`${icon} w-4 mr-2`}></i><span>{label}</span></div><p className="text-lg font-bold text-gray-900 dark:text-white">{typeof value === 'number' ? value.toLocaleString() : value}</p></div>);
    const LinkButton = ({ icon, url, text }) => { if (!url) return null; return <a href={url} target="_blank" rel="noopener noreferrer" className="flex items-center p-2 rounded-md bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors"><i className={`${icon} w-5 mr-3 text-primary`}></i><span className="text-sm font-medium">{text}</span><i className="fas fa-external-link-alt text-xs text-gray-400 dark:text-gray-500 ml-auto"></i></a>; };
    const ErrorDisplay = ({ title, message }) => (<div className="bg-red-50 dark:bg-red-900/20 border border-danger/50 text-danger p-4 rounded-lg flex items-center space-x-3 my-4"><i className="fas fa-exclamation-triangle text-xl"></i><div><h4 className="font-semibold">{title}</h4><p className="text-sm">{message}</p></div></div>);
    return (<div className="space-y-6"><div className="flex justify-between items-start"><div><div className="flex items-center space-x-4 mb-2"><img src={coin.image} alt={coin.name} className="w-12 h-12" /><div className="flex items-center gap-3"><div><h1 className="text-3xl font-bold text-gray-900 dark:text-white">{coin.name}</h1><p className="text-lg text-gray-500 dark:text-gray-400">{coin.symbol.toUpperCase()}</p></div><div className="flex items-center"><button onClick={handleFavoriteToggle} className={`text-2xl p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors ${isFav ? 'text-yellow-400' : 'text-gray-400 dark:text-gray-500'}`} aria-label={isFav ? `Remove ${coin.name} from favs` : `Add ${coin.name} to favs`}><i className={`${isFav ? 'fas' : 'far'} fa-star ${isAnimating ? 'animate-favorite-pop' : ''}`}></i></button><button onClick={() => setAlertModalOpen(true)} className="text-2xl p-2 rounded-full text-gray-400 dark:text-gray-500 hover:text-primary hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors" aria-label={`Set price alert for ${coin.name}`}><i className="fas fa-bell"></i></button></div></div></div></div><button onClick={() => setActivePage('Dashboard')} className="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-800 dark:text-white font-semibold py-2 px-4 rounded-lg transition-colors"><i className="fas fa-arrow-left mr-2"></i>Back</button></div><div className="space-y-3"><AccordionItem title="Overview & Chart" icon="fa-chart-bar" defaultOpen={true}><div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-6 gap-4 mb-4"><StatCard label="Price" value={`$${coin.current_price.toLocaleString()}`} /><StatCard label="24h Change" value={`${coin.price_change_percentage_24h.toFixed(2)}%`} /><StatCard label="Market Cap" value={`$${(coin.market_cap / 1e9).toFixed(2)}B`} /><StatCard label="Volume" value={`$${(coin.total_volume / 1e6).toFixed(2)}M`} /><StatCard label="All-Time High" value={`$${coin.ath.toLocaleString()}`} /><StatCard label="From ATH" value={`${coin.ath_change_percentage.toFixed(2)}%`} /></div>{loadingDetails ? <p>Loading description...</p> : detailsError ? <ErrorDisplay title="Could not load details" message={detailsError} /> : (<div className="text-sm text-gray-600 dark:text-gray-400 my-4 prose prose-sm dark:prose-invert max-w-none" dangerouslySetInnerHTML={{ __html: coinDetails?.description?.split('. ')[0] + '.' || 'No description.' }}></div>)}<div className="h-[450px]"><TradingViewWidget coinSymbol={coin.symbol} /></div></AccordionItem><AccordionItem title="AI Trend Prediction" icon="fa-brain"><TrendPredictionCard prediction={trendPrediction} loading={predictionLoading} error={predictionError} /></AccordionItem><AccordionItem title="Fundamental Analysis" icon="fa-book-reader"><FundamentalsCard data={fundamentals} loading={loadingFundamentals} error={fundamentalsError} /></AccordionItem><AccordionItem title="Community & Developer Activity" icon="fa-satellite-dish">{loadingDetails ? <p>Loading details...</p> : detailsError ? <ErrorDisplay title="Could not load community data" message={detailsError} /> : !coinDetails ? <p>No data.</p> : (<div className="grid grid-cols-1 md:grid-cols-2 gap-6"><div><h3 className="text-lg font-semibold mb-3 flex items-center"><i className="fas fa-users mr-2 text-secondary"></i>Community</h3><div className="grid grid-cols-2 gap-3 mb-4"><StatDisplay icon="fab fa-twitter" label="Twitter Followers" value={coinDetails.communityStats.twitterFollowers} /><StatDisplay icon="fab fa-reddit-alien" label="Reddit Subscribers" value={coinDetails.communityStats.redditSubscribers} /></div><div className="space-y-2"><LinkButton icon="fas fa-home" url={coinDetails.links.homepage} text="Homepage" /><LinkButton icon="fas fa-cube" url={coinDetails.links.explorer} text="Explorer" /><LinkButton icon="fab fa-twitter" url={coinDetails.links.twitter} text="Twitter" /><LinkButton icon="fab fa-reddit-alien" url={coinDetails.links.reddit} text="Reddit" /></div></div><div><h3 className="text-lg font-semibold mb-3 flex items-center"><i className="fas fa-code-branch mr-2 text-secondary"></i>Developer Activity</h3><div className="grid grid-cols-2 gap-3 mb-4"><StatDisplay icon="fas fa-star" label="GitHub Stars" value={coinDetails.devStats.stars} /><StatDisplay icon="fas fa-code-branch" label="Forks" value={coinDetails.devStats.forks} /><StatDisplay icon="fas fa-users" label="Subscribers" value={coinDetails.devStats.subscribers} /><StatDisplay icon="fas fa-history" label="Commits (4w)" value={coinDetails.devStats.commits4w} /></div><div className="space-y-2"><LinkButton icon="fab fa-github" url={coinDetails.links.github} text="Main Repository" /></div></div></div>)}</AccordionItem><AccordionItem title="Latest News" icon="fa-newspaper">{loadingNews ? <p>Loading news...</p> : newsError ? <ErrorDisplay title="Could not load news" message={newsError} /> : (<div className="space-y-4">{news.length > 0 ? (news.map(article => <NewsCard key={article.id} article={article} />)) : (<p className="text-gray-500">No recent news found for {coin.name}.</p>)}</div>)}</AccordionItem></div>{isAlertModalOpen && (<CreateAlertModal defaultCoinId={coin.id} onClose={() => setAlertModalOpen(false)} />)}</div>);
};

const Compare = ({ onCoinSelect }) => {
    const { coins } = useDApp(); const [selectedCoinIds, setSelectedCoinIds] = React.useState([]); const [searchTerm, setSearchTerm] = React.useState(''); const MAX_SELECTION = 3;
    const handleSelectCoin = (coinId) => { setSelectedCoinIds(prev => { if (prev.includes(coinId)) return prev.filter(id => id !== coinId); if (prev.length < MAX_SELECTION) return [...prev, coinId]; return prev; }); };
    const selectedCoins = React.useMemo(() => { const coinMap = new Map(coins.map(c => [c.id, c])); return selectedCoinIds.map(id => coinMap.get(id)).filter((c) => c !== undefined); }, [selectedCoinIds, coins]);
    const filteredCoinsForSelection = React.useMemo(() => { if (!searchTerm) return coins; return coins.filter(coin => coin.name.toLowerCase().includes(searchTerm.toLowerCase()) || coin.symbol.toLowerCase().includes(searchTerm.toLowerCase())); }, [coins, searchTerm]);
    const isSelectionDisabled = selectedCoinIds.length >= MAX_SELECTION;
    const CoinSelectorCard = ({ coin, isSelected, onSelect, isDisabled }) => (<button onClick={() => onSelect(coin.id)} disabled={isDisabled && !isSelected} className={`flex flex-col items-center justify-center text-center p-3 bg-white dark:bg-gray-700 rounded-lg transition-all duration-200 border-2 ${isSelected ? 'border-primary bg-gray-100 dark:bg-gray-600' : 'border-transparent hover:bg-gray-100 dark:hover:bg-gray-600'} ${isDisabled && !isSelected ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}><img src={coin.image} alt={coin.name} className="w-8 h-8 mb-2" /><span className="text-sm font-semibold">{coin.name}</span><span className="text-xs text-gray-500 dark:text-gray-400">{coin.symbol.toUpperCase()}</span></button>);
    const AIComparison = ({ coins }) => { const [comparison, setComparison] = React.useState(''); const [loading, setLoading] = React.useState(true); React.useEffect(() => { const fetchComparison = async () => { setLoading(true); const result = await getAIComparison(coins); setComparison(result); setLoading(false); }; if (coins.length >= 2) { fetchComparison(); } }, [coins]); return (<div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg shadow-lg mt-6"><h3 className="text-xl font-semibold text-primary mb-2"><i className="fas fa-brain mr-2"></i>AI-Powered Comparison</h3>{loading ? (<p className="text-gray-600 dark:text-gray-300">Generating AI analysis...</p>) : (<p className="text-gray-600 dark:text-gray-300 leading-relaxed">{comparison}</p>)}</div>); };
    const renderComparisonTable = () => (<div className="mt-6 bg-gray-100 dark:bg-gray-800 p-4 rounded-lg overflow-x-auto"><table className="w-full text-left"><thead><tr className="border-b border-gray-200 dark:border-gray-700 text-gray-500 dark:text-gray-400"><th className="p-3">Metric</th>{selectedCoins.map(coin => (<th key={coin.id} className="p-3 text-center"><div className="flex flex-col items-center"><img src={coin.image} alt={coin.name} className="w-8 h-8 mb-1"/>{coin.name}</div></th>))}</tr></thead><tbody><tr className="border-b border-gray-200 dark:border-gray-700"><td className="p-3 font-semibold">Price</td>{selectedCoins.map(c => <td key={c.id} className="p-3 text-center font-mono">${c.current_price.toLocaleString()}</td>)}</tr><tr className="border-b border-gray-200 dark:border-gray-700"><td className="p-3 font-semibold">24h Change</td>{selectedCoins.map(c => (<td key={c.id} className={`p-3 text-center font-mono ${c.price_change_percentage_24h >= 0 ? 'text-success' : 'text-danger'}`}>{c.price_change_percentage_24h.toFixed(2)}%</td>))}</tr><tr className="border-b border-gray-200 dark:border-gray-700"><td className="p-3 font-semibold">Market Cap</td>{selectedCoins.map(c => <td key={c.id} className="p-3 text-center font-mono">${c.market_cap.toLocaleString()}</td>)}</tr><tr className="border-b border-gray-200 dark:border-gray-700 last:border-b-0"><td className="p-3 font-semibold">24h Volume</td>{selectedCoins.map(c => <td key={c.id} className="p-3 text-center font-mono">${c.total_volume.toLocaleString()}</td>)}</tr><tr className="bg-gray-200/50 dark:bg-gray-700/50"><td className="p-3 font-semibold"></td>{selectedCoins.map(c => (<td key={c.id} className="p-3 text-center"><button onClick={() => onCoinSelect(c)} className="bg-secondary text-white text-sm font-bold py-1 px-3 rounded-md hover:bg-purple-500 transition-colors">View Details</button></td>))}</tr></tbody></table></div>);
    return (<div className="space-y-6"><div className="flex justify-between items-center"><h1 className="text-3xl font-bold text-gray-900 dark:text-white">Coin Comparison</h1>{selectedCoinIds.length > 0 && (<button onClick={() => setSelectedCoinIds([])} className="bg-danger text-white px-4 py-2 rounded-md hover:bg-red-500">Clear Selection</button>)}</div><div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg"><div className="flex flex-col sm:flex-row justify-between sm:items-center mb-3 gap-3"><h2 className="text-xl font-semibold">Select up to {MAX_SELECTION} coins to compare</h2><div className="relative w-full sm:w-auto sm:max-w-xs"><input type="text" placeholder="Search to add coins..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="w-full bg-white dark:bg-gray-700 text-gray-900 dark:text-white p-2 pl-8 rounded-md border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-primary"/><i className="fas fa-search absolute left-2.5 top-1/2 -translate-y-1/2 text-gray-400"></i></div></div>{filteredCoinsForSelection.length > 0 ? (<div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 xl:grid-cols-8 gap-3">{filteredCoinsForSelection.map(coin => (<CoinSelectorCard key={coin.id} coin={coin} isSelected={selectedCoinIds.includes(coin.id)} onSelect={handleSelectCoin} isDisabled={isSelectionDisabled}/>))}</div>) : (<div className="text-center py-6 text-gray-500 dark:text-gray-400"><p>No coins found for "{searchTerm}".</p></div>)}</div>{selectedCoins.length >= 2 ? (<>{renderComparisonTable()}<AIComparison coins={selectedCoins} /></>) : (<div className="text-center py-10 bg-gray-100 dark:bg-gray-800 rounded-lg"><i className="fas fa-info-circle text-3xl text-gray-400 dark:text-gray-500 mb-3"></i><p className="text-gray-500 dark:text-gray-400">Please select at least two coins to start the comparison.</p></div>)}</div>);
};

const NotificationCenter = () => {
  const { notifications, removeNotification } = useNotifications();
  const NOTIFICATION_TIMEOUT = 7000;
  const getNotificationDetails = (type) => { switch (type) { case 'alert': return { icon: 'fa-bell', color: 'bg-secondary', title: 'Price Alert Triggered!' }; case 'info': return { icon: 'fa-info-circle', color: 'bg-primary', title: 'Order Update' }; case 'error': default: return { icon: 'fa-exclamation-circle', color: 'bg-danger', title: 'Error' }; } };
  const NotificationToast = ({ notification, onRemove }) => {
    React.useEffect(() => { const timer = setTimeout(() => { onRemove(notification.id); }, NOTIFICATION_TIMEOUT); return () => clearTimeout(timer); }, [notification.id, onRemove]);
    const { icon, color, title } = getNotificationDetails(notification.type);
    const borderColor = notification.type === 'alert' ? 'border-secondary' : 'border-primary';
    return (<div className={`bg-white dark:bg-gray-800 rounded-lg shadow-2xl p-4 w-80 animate-fade-in-right border-l-4 ${borderColor}`}><div className="flex items-start"><div className={`flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center mr-3 ${color}`}><i className={`fas ${icon} text-white`}></i></div><div className="flex-1"><p className="font-semibold text-gray-900 dark:text-white">{title}</p><p className="text-sm text-gray-600 dark:text-gray-300">{notification.message}</p></div><button onClick={() => onRemove(notification.id)} className="ml-2 text-gray-400 dark:text-gray-500 hover:text-gray-800 dark:hover:text-white">&times;</button></div></div>);
  };
  const styles = document.createElement('style'); styles.innerHTML = `@keyframes fadeInRight { from { opacity: 0; transform: translateX(100%); } to { opacity: 1; transform: translateX(0); } } .animate-fade-in-right { animation: fadeInRight 0.5s ease-out forwards; }`; document.head.appendChild(styles);
  return (<div className="fixed top-5 right-5 z-50 space-y-3">{notifications.map(notification => (<NotificationToast key={notification.id} notification={notification} onRemove={removeNotification} />))}</div>);
};

const AlertsPage = () => {
    const { alerts, removeAlert } = useAlerts(); const { coins } = useDApp(); const [isModalOpen, setModalOpen] = React.useState(false);
    const coinMap = React.useMemo(() => new Map(coins.map(c => [c.id, c])), [coins]);
    const activeAlerts = alerts.filter(a => a.status === 'active');
    const triggeredAlerts = alerts.filter(a => a.status === 'triggered');
    const AlertItem = ({ alert, coin, onRemove }) => { const conditionText = alert.condition === 'above' ? 'is above' : 'is below'; const isTriggered = alert.status === 'triggered'; return (<div className={`bg-white dark:bg-gray-700 p-4 rounded-lg flex items-center justify-between transition-opacity ${isTriggered ? 'opacity-60' : ''}`}><div className="flex items-center space-x-4">{coin ? <img src={coin.image} alt={coin.name} className="w-10 h-10" /> : <div className="w-10 h-10 bg-gray-200 dark:bg-gray-600 rounded-full"></div>}<div><h4 className="font-bold text-lg">{coin?.name || alert.coinId}</h4><p className="text-sm text-gray-600 dark:text-gray-300">Notify when price <span className="font-semibold text-primary">{conditionText}</span> ${alert.targetPrice.toLocaleString()}</p></div></div><div className="flex items-center space-x-4">{isTriggered && (<span className="text-sm font-semibold bg-green-100 text-green-700 dark:bg-green-500/20 dark:text-success px-3 py-1 rounded-full"><i className="fas fa-check-circle mr-2"></i>Triggered</span>)}<button onClick={() => onRemove(alert.id)} className="text-gray-500 dark:text-gray-400 hover:text-danger transition-colors" aria-label="Delete alert"><i className="fas fa-trash"></i></button></div></div>); };
    return (<div className="space-y-6"><div className="flex justify-between items-center"><h1 className="text-3xl font-bold text-gray-900 dark:text-white">Price Alerts</h1><button onClick={() => setModalOpen(true)} className="bg-primary text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-500 transition-colors"><i className="fas fa-plus mr-2"></i>Create New Alert</button></div><div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg shadow-lg"><h2 className="text-xl font-semibold mb-4 text-secondary"><i className="fas fa-hourglass-half mr-2"></i>Active Alerts ({activeAlerts.length})</h2>{activeAlerts.length > 0 ? (<div className="space-y-3">{activeAlerts.map(alert => (<AlertItem key={alert.id} alert={alert} coin={coinMap.get(alert.coinId)} onRemove={removeAlert} />))}</div>) : (<p className="text-gray-500 dark:text-gray-500 text-center py-4">You have no active alerts.</p>)}</div><div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg shadow-lg"><h2 className="text-xl font-semibold mb-4 text-gray-500 dark:text-gray-400"><i className="fas fa-history mr-2"></i>Triggered History ({triggeredAlerts.length})</h2>{triggeredAlerts.length > 0 ? (<div className="space-y-3">{triggeredAlerts.map(alert => (<AlertItem key={alert.id} alert={alert} coin={coinMap.get(alert.coinId)} onRemove={removeAlert} />))}</div>) : (<p className="text-gray-500 dark:text-gray-500 text-center py-4">No alerts have been triggered yet.</p>)}</div>{isModalOpen && <CreateAlertModal onClose={() => setModalOpen(false)} />}</div>);
};

// =========================================================================
// ========= END OF CONSOLIDATED COMPONENTS ================================
// =========================================================================


const Dashboard = ({ onCoinSelect }) => {
  const { coins, loading: coinsLoading, error: coinsError, fearAndGreed, dailySummary } = useDApp();
  const { favoriteCoinIds } = useFavorites();
  const [news, setNews] = React.useState([]);
  const [searchTerm, setSearchTerm] = React.useState('');
  const favoriteCoins = React.useMemo(() => coins.filter(c => favoriteCoinIds.includes(c.id)), [coins, favoriteCoinIds]);
  const filteredCoins = React.useMemo(() => {
      if (!searchTerm) return coins.slice(0, 8);
      return coins.filter(c => c.name.toLowerCase().includes(searchTerm.toLowerCase()) || c.symbol.toLowerCase().includes(searchTerm.toLowerCase()));
  }, [coins, searchTerm]);
  React.useEffect(() => { getLatestNews().then(setNews); }, []);
  
  const AISummary = () => (
    <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg shadow-lg mb-6">
      <h2 className="text-lg font-semibold text-primary mb-2">
        <i className="fas fa-brain mr-2"></i>AI Daily Summary
      </h2>
      <p className="text-gray-600 dark:text-gray-300">{dailySummary ?? "Generating AI summary..."}</p>
    </div>
  );
  
  return (
    <div className="space-y-6">
      <h1 className="text-3xl font-bold text-gray-900 dark:text-white">Dashboard</h1>
      <AISummary />
      <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg shadow-lg">
          <h2 className="text-xl font-semibold mb-4 text-secondary"><i className="fas fa-star mr-2"></i>My Favorites</h2>
          {favoriteCoins.length > 0 ? (
              <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-4">
                  {favoriteCoins.map(coin => <CoinCard key={coin.id} coin={coin} onClick={() => onCoinSelect(coin)} />)}
              </div>
          ) : ( <div className="text-center py-4 text-gray-500 dark:text-gray-400"><p>Click the <i className="far fa-star text-yellow-400"></i> on any coin to add it here!</p></div> )}
      </div>
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="lg:col-span-2 space-y-6">
          <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg shadow-lg">
            <div className="flex justify-between items-center mb-4">
                <h2 className="text-xl font-semibold">Market Overview</h2>
                <input type="text" placeholder="Search coins..." value={searchTerm} onChange={e => setSearchTerm(e.target.value)} className="w-full sm:w-auto bg-white dark:bg-gray-700 p-2 pl-8 rounded-md border focus:outline-none focus:ring-2 focus:ring-primary"/>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-4">
              {coinsLoading ? <p>Loading market data...</p> : coinsError ? <p className="text-danger">{coinsError}</p> : filteredCoins.map(coin => <CoinCard key={coin.id} coin={coin} onClick={() => onCoinSelect(coin)} />)}
            </div>
          </div>
          <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg shadow-lg">
            <h2 className="text-xl font-semibold mb-4">Latest News</h2>
            <div className="space-y-4">{news.map(article => <NewsCard key={article.id} article={article} />)}</div>
          </div>
        </div>
        <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg shadow-lg h-fit">
          <h2 className="text-xl font-semibold mb-4">Market Sentiment</h2>
           {fearAndGreed ? <FearGreedIndex value={fearAndGreed.value} classification={fearAndGreed.value_classification} /> : <p>Loading sentiment...</p>}
        </div>
      </div>
    </div>
  );
};

const App = () => {
  const [activePage, setActivePage] = React.useState('Dashboard');
  const [selectedCoin, setSelectedCoin] = React.useState(null);

  const handleSelectCoin = (coin) => {
    setSelectedCoin(coin);
    setActivePage('Coin Research');
  };

  const renderPage = React.useMemo(() => {
    switch (activePage) {
      case 'Dashboard':
        return <Dashboard onCoinSelect={handleSelectCoin} />;
      case 'Portfolio':
        return <Portfolio setActivePage={setActivePage} />;
      case 'Recommendations':
        return <Recommendations />;
      case 'Alerts':
        return <AlertsPage />;
      case 'Compare':
        return <Compare onCoinSelect={handleSelectCoin} />;
      case 'Learning Center':
        return <LearningCenter />;
      case 'Coin Research':
        if (selectedCoin) {
          return <CoinResearch coin={selectedCoin} setActivePage={setActivePage} />;
        }
        // Fallback if no coin is selected but page is active
        setActivePage('Dashboard'); 
        return <Dashboard onCoinSelect={handleSelectCoin} />;
      default:
        return <Dashboard onCoinSelect={handleSelectCoin} />;
    }
  }, [activePage, selectedCoin]);

  return (
    <ThemeProvider>
      <PortfolioProvider>
        <FavoritesProvider>
          <AlertsProvider>
            <NotificationsProvider>
              <DAppProvider>
                <div className="flex min-h-screen font-sans">
                  <Sidebar activePage={activePage} setActivePage={setActivePage} />
                  <main key={activePage} className="flex-1 p-4 sm:p-6 lg:p-8 ml-16 md:ml-64 transition-all duration-300 animate-page-fade-in">
                    {renderPage}
                  </main>
                  <NotificationCenter />
                </div>
              </DAppProvider>
            </NotificationsProvider>
          </AlertsProvider>
        </FavoritesProvider>
      </PortfolioProvider>
    </ThemeProvider>
  );
};


//========= RENDER APPLICATION =========//
const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}
const root = ReactDOM.createRoot(rootElement);
root.render(<App />);

    </script>
  </body>
</html>